{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WebQuest: Algoritmos de Busca em Strings","text":"<p>Bem-vindo(a) ao WebQuest sobre Busca em Strings!</p> <p>Neste WebQuest, voc\u00ea ir\u00e1 explorar, implementar e analisar algoritmos cl\u00e1ssicos de busca em strings usando Python. Prepare-se para uma jornada atrav\u00e9s dos algoritmos Naive, KMP, Rabin-Karp e Aho-Corasick!</p>"},{"location":"#o-que-voce-vai-aprender","title":"O que voc\u00ea vai aprender","text":"<ul> <li>Compreender os fundamentos da busca em strings</li> <li>Implementar algoritmos cl\u00e1ssicos em Python</li> <li>Analisar complexidades e performance</li> <li>Comparar diferentes abordagens</li> <li>Aplicar os conhecimentos em problemas reais</li> </ul>"},{"location":"#metodologia-webquest","title":"Metodologia WebQuest","text":"<p>Esta experi\u00eancia de aprendizagem segue a metodologia WebQuest, que combina:</p> <ul> <li>Investiga\u00e7\u00e3o orientada atrav\u00e9s de recursos selecionados</li> <li>Aprendizagem ativa com implementa\u00e7\u00f5es pr\u00e1ticas</li> <li>An\u00e1lise cr\u00edtica de algoritmos e suas aplica\u00e7\u00f5es</li> <li>S\u00edntese do conhecimento atrav\u00e9s de compara\u00e7\u00f5es</li> </ul>"},{"location":"#algoritmos-estudados","title":"Algoritmos Estudados","text":"Algoritmo NaiveKMP (Knuth-Morris-Pratt)Rabin-KarpAho-Corasick <p>O m\u00e9todo mais simples e intuitivo para busca em strings.</p> <ul> <li>Complexidade: O(n\u00d7m)</li> <li>Vantagem: Simplicidade de implementa\u00e7\u00e3o</li> <li>Desvantagem: Ineficiente para textos grandes</li> </ul> <p>Algoritmo eficiente que evita retrocessos desnecess\u00e1rios.</p> <ul> <li>Complexidade: O(n+m)</li> <li>Vantagem: Linear, sem backtracking</li> <li>Aplica\u00e7\u00e3o: Busca \u00fanica de padr\u00e3o</li> </ul> <p>Utiliza hashing para compara\u00e7\u00e3o eficiente de substrings.</p> <ul> <li>Complexidade: O(n+m) m\u00e9dio</li> <li>Vantagem: M\u00faltiplos padr\u00f5es, rolling hash</li> <li>Aplica\u00e7\u00e3o: Detec\u00e7\u00e3o de pl\u00e1gio</li> </ul> <p>Busca m\u00faltiplos padr\u00f5es simultaneamente usando aut\u00f4mato finito.</p> <ul> <li>Complexidade: O(n+m+z)</li> <li>Vantagem: M\u00faltiplos padr\u00f5es em uma \u00fanica passada</li> <li>Aplica\u00e7\u00e3o: Filtros de conte\u00fado, bioinform\u00e1tica</li> </ul>"},{"location":"#roteiro-de-estudos","title":"Roteiro de Estudos","text":"<pre><code>graph TD\n    A[In\u00edcio] --&gt; B[Introdu\u00e7\u00e3o ao Problema]\n    B --&gt; C[Algoritmo Naive]\n    C --&gt; D[KMP Algorithm]\n    D --&gt; E[Rabin-Karp]\n    E --&gt; F[Aho-Corasick]\n    F --&gt; G[An\u00e1lise Comparativa]\n    G --&gt; H[Atividades Pr\u00e1ticas]\n    H --&gt; I[Avalia\u00e7\u00e3o Final]</code></pre>"},{"location":"#como-usar-este-webquest","title":"Como usar este WebQuest","text":"<ol> <li>Navegue sequencialmente pelos algoritmos</li> <li>Execute os c\u00f3digos fornecidos</li> <li>Experimente varia\u00e7\u00f5es dos exemplos</li> <li>Complete as atividades propostas</li> <li>Reflita sobre as quest\u00f5es apresentadas</li> </ol> <p>Dica de Estudo</p> <p>Mantenha um caderno de anota\u00e7\u00f5es para registrar suas descobertas e d\u00favidas. A programa\u00e7\u00e3o se aprende praticando!</p>"},{"location":"#recursos-interativos","title":"Recursos Interativos","text":"<ul> <li>Visualiza\u00e7\u00f5es dos algoritmos em a\u00e7\u00e3o</li> <li>C\u00f3digos comentados linha por linha</li> <li>Comparativos de performance com gr\u00e1ficos</li> <li>Exerc\u00edcios pr\u00e1ticos com solu\u00e7\u00f5es</li> <li>Testes automatizados para valida\u00e7\u00e3o</li> </ul> <p>Pronto para come\u00e7ar? Vamos iniciar pela Introdu\u00e7\u00e3o ao Problema! \ud83d\ude80</p>"},{"location":"algoritmos/aho-corasick/","title":"Aho-Corasick Algorithm","text":""},{"location":"algoritmos/aho-corasick/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>O algoritmo Aho-Corasick \u00e9 uma extens\u00e3o poderosa do algoritmo KMP que permite buscar m\u00faltiplos padr\u00f5es simultaneamente em um texto. Desenvolvido por Alfred Aho e Margaret Corasick em 1975, este algoritmo \u00e9 amplamente utilizado em sistemas de detec\u00e7\u00e3o de malware, filtros de conte\u00fado, an\u00e1lise de logs e bioinform\u00e1tica.</p> <p>Caracter\u00edsticas Principais</p> <ul> <li>Busca m\u00faltiplos padr\u00f5es em uma \u00fanica passagem</li> <li>Complexidade temporal linear O(n + m + z)</li> <li>Baseado em uma trie com links de falha</li> <li>N\u00e3o h\u00e1 retrocessos durante a busca</li> </ul>"},{"location":"algoritmos/aho-corasick/#conceito-e-motivacao","title":"Conceito e Motiva\u00e7\u00e3o","text":""},{"location":"algoritmos/aho-corasick/#problema","title":"Problema","text":"<p>Imagine que voc\u00ea precisa verificar se um texto cont\u00e9m qualquer uma das seguintes palavras proibidas: <code>[\"spam\", \"scam\", \"phishing\", \"malware\"]</code>. Com algoritmos tradicionais, voc\u00ea precisaria fazer 4 buscas separadas. O Aho-Corasick resolve isso em uma \u00fanica passagem!</p>"},{"location":"algoritmos/aho-corasick/#como-funciona","title":"Como Funciona","text":"<p>O algoritmo constr\u00f3i uma trie (\u00e1rvore de prefixos) dos padr\u00f5es e adiciona links de falha que permitem transi\u00e7\u00f5es eficientes quando um padr\u00e3o n\u00e3o \u00e9 encontrado.</p>"},{"location":"algoritmos/aho-corasick/#estrutura-de-dados","title":"Estrutura de Dados","text":"<pre><code>Trie + Failure Links + Output Function = Aho-Corasick Automaton\n</code></pre>"},{"location":"algoritmos/aho-corasick/#implementacao-detalhada","title":"Implementa\u00e7\u00e3o Detalhada","text":""},{"location":"algoritmos/aho-corasick/#inicializacao-da-classe","title":"Inicializa\u00e7\u00e3o da Classe","text":"<pre><code>class AhoCorasick:\n    def __init__(self,\n                 patterns: List[str],\n                 case_sensitive: bool = True,\n                 only_whole_words: bool = False):\n        \"\"\"\n        Inicializa o automato Aho-Corasick.\n        \"\"\"\n        self.case_sensitive = case_sensitive\n        self.only_whole_words = only_whole_words\n\n        # Valida\u00e7\u00e3o e preprocessamento dos padr\u00f5es\n        self.patterns = self._validate_and_preprocess_patterns(patterns)\n\n        if not self.patterns:\n            raise ValueError(\"Nenhum padr\u00e3o v\u00e1lido fornecido\")\n\n        # Estruturas do automato\n        self.goto = {}              # Fun\u00e7\u00e3o de transi\u00e7\u00e3o\n        self.fail = {}              # Fun\u00e7\u00e3o de falha\n        self.output = defaultdict(set)  # Fun\u00e7\u00e3o de sa\u00edda\n\n        # Constru\u00e7\u00e3o do automato\n        self._build_goto_function()\n        self._build_failure_function()\n</code></pre> <p>Explica\u00e7\u00e3o linha por linha:</p> <ol> <li>Par\u00e2metros de configura\u00e7\u00e3o:</li> <li><code>case_sensitive</code>: Controla se a busca diferencia mai\u00fasculas/min\u00fasculas</li> <li> <p><code>only_whole_words</code>: Define se deve buscar apenas palavras completas</p> </li> <li> <p>Estruturas principais:</p> </li> <li><code>self.goto = {}</code>: Fun\u00e7\u00e3o de transi\u00e7\u00e3o - mapeia (estado, caractere) \u2192 pr\u00f3ximo estado</li> <li><code>self.fail = {}</code>: Fun\u00e7\u00e3o de falha - mapeia estado \u2192 estado de fallback</li> <li> <p><code>self.output = defaultdict(set)</code>: Fun\u00e7\u00e3o de sa\u00edda - mapeia estado \u2192 conjunto de padr\u00f5es encontrados</p> </li> <li> <p>Constru\u00e7\u00e3o do automato:</p> </li> <li><code>_build_goto_function()</code>: Constr\u00f3i a trie dos padr\u00f5es</li> <li><code>_build_failure_function()</code>: Adiciona os links de falha</li> </ol>"},{"location":"algoritmos/aho-corasick/#validacao-e-preprocessamento","title":"Valida\u00e7\u00e3o e Preprocessamento","text":"<pre><code>def _validate_and_preprocess_patterns(self, patterns: List[str]) -&gt; List[str]:\n    \"\"\"Valida e preprocessa os padr\u00f5es de entrada.\"\"\"\n    if not patterns:\n        return []\n\n    processed = []\n    seen = set()\n\n    for pattern in patterns:\n        if not isinstance(pattern, str):\n            continue\n\n        # Preprocessamento baseado nas configura\u00e7\u00f5es\n        if not self.case_sensitive:\n            pattern = pattern.lower()\n\n        # Remove duplicatas\n        if pattern not in seen:\n            processed.append(pattern)\n            seen.add(pattern)\n\n    return processed\n</code></pre> <p>Explica\u00e7\u00e3o detalhada:</p> <ol> <li>Valida\u00e7\u00e3o b\u00e1sica (linhas 3-4):</li> <li><code>if not patterns:</code> - Verifica se a lista n\u00e3o est\u00e1 vazia</li> <li> <p><code>return []</code> - Retorna lista vazia se n\u00e3o h\u00e1 padr\u00f5es</p> </li> <li> <p>Inicializa\u00e7\u00e3o (linhas 6-7):</p> </li> <li><code>processed = []</code> - Lista para padr\u00f5es processados</li> <li> <p><code>seen = set()</code> - Conjunto para detectar duplicatas</p> </li> <li> <p>Processamento de cada padr\u00e3o (linhas 9-10):</p> </li> <li><code>for pattern in patterns:</code> - Itera sobre cada padr\u00e3o</li> <li> <p><code>if not isinstance(pattern, str):</code> - Verifica se \u00e9 string</p> </li> <li> <p>Normaliza\u00e7\u00e3o (linhas 13-14):</p> </li> <li><code>if not self.case_sensitive:</code> - Se n\u00e3o diferencia mai\u00fasculas/min\u00fasculas</li> <li> <p><code>pattern = pattern.lower()</code> - Converte para min\u00fasculas</p> </li> <li> <p>Remo\u00e7\u00e3o de duplicatas (linhas 16-19):</p> </li> <li><code>if pattern not in seen:</code> - Se ainda n\u00e3o foi processado</li> <li><code>processed.append(pattern)</code> - Adiciona \u00e0 lista final</li> <li><code>seen.add(pattern)</code> - Marca como processado</li> </ol>"},{"location":"algoritmos/aho-corasick/#construcao-da-funcao-goto-trie","title":"Constru\u00e7\u00e3o da Fun\u00e7\u00e3o Goto (Trie)","text":"<pre><code>def _build_goto_function(self):\n    \"\"\"Constr\u00f3i a fun\u00e7\u00e3o goto (trie).\"\"\"\n    # Estado inicial\n    self.goto[0] = {}\n    state_count = 1\n\n    # Constr\u00f3i a trie\n    for pattern_idx, pattern in enumerate(self.patterns):\n        current_state = 0\n\n        for char in pattern:\n            if char not in self.goto[current_state]:\n                self.goto[current_state][char] = state_count\n                self.goto[state_count] = {}\n                state_count += 1\n\n            current_state = self.goto[current_state][char]\n\n        # Marca o estado final\n        self.output[current_state].add(pattern_idx)\n</code></pre> <p>Explica\u00e7\u00e3o linha por linha:</p> <ol> <li>Inicializa\u00e7\u00e3o (linhas 3-4):</li> <li><code>self.goto[0] = {}</code> - Estado inicial (raiz) sem transi\u00e7\u00f5es</li> <li> <p><code>state_count = 1</code> - Contador para pr\u00f3ximos estados</p> </li> <li> <p>Para cada padr\u00e3o (linhas 7-8):</p> </li> <li><code>for pattern_idx, pattern in enumerate(self.patterns):</code> - Itera com \u00edndice</li> <li> <p><code>current_state = 0</code> - Inicia na raiz</p> </li> <li> <p>Constru\u00e7\u00e3o do caminho (linhas 10-15):</p> </li> <li><code>for char in pattern:</code> - Para cada caractere do padr\u00e3o</li> <li><code>if char not in self.goto[current_state]:</code> - Se transi\u00e7\u00e3o n\u00e3o existe</li> <li><code>self.goto[current_state][char] = state_count</code> - Cria transi\u00e7\u00e3o</li> <li><code>self.goto[state_count] = {}</code> - Inicializa novo estado</li> <li> <p><code>state_count += 1</code> - Incrementa contador</p> </li> <li> <p>Avan\u00e7o no automato (linha 15):</p> </li> <li> <p><code>current_state = self.goto[current_state][char]</code> - Move para pr\u00f3ximo estado</p> </li> <li> <p>Marca fim do padr\u00e3o (linha 18):</p> </li> <li><code>self.output[current_state].add(pattern_idx)</code> - Adiciona padr\u00e3o ao estado final</li> </ol>"},{"location":"algoritmos/aho-corasick/#construcao-da-funcao-de-falha","title":"Constru\u00e7\u00e3o da Fun\u00e7\u00e3o de Falha","text":"<pre><code>def _build_failure_function(self):\n    \"\"\"Constr\u00f3i a fun\u00e7\u00e3o de falha usando BFS.\"\"\"\n    # Inicializa a fun\u00e7\u00e3o de falha\n    self.fail[0] = 0\n\n    # Fila para BFS\n    queue = deque()\n\n    # Estados de profundidade 1 t\u00eam falha para o estado 0\n    for char, state in self.goto[0].items():\n        self.fail[state] = 0\n        queue.append(state)\n\n    # Processa os demais estados\n    while queue:\n        current_state = queue.popleft()\n\n        for char, next_state in self.goto[current_state].items():\n            queue.append(next_state)\n\n            # Encontra o estado de falha\n            failure_state = self.fail[current_state]\n\n            while failure_state != 0 and char not in self.goto[failure_state]:\n                failure_state = self.fail[failure_state]\n\n            if char in self.goto[failure_state]:\n                failure_state = self.goto[failure_state][char]\n\n            self.fail[next_state] = failure_state\n\n            # Combina as sa\u00eddas\n            self.output[next_state].update(self.output[failure_state])\n</code></pre> <p>Explica\u00e7\u00e3o detalhada:</p> <ol> <li>Inicializa\u00e7\u00e3o (linhas 3-6):</li> <li><code>self.fail[0] = 0</code> - Raiz tem falha para si mesma</li> <li> <p><code>queue = deque()</code> - Fila para processamento BFS</p> </li> <li> <p>Estados de profundidade 1 (linhas 8-11):</p> </li> <li><code>for char, state in self.goto[0].items():</code> - Filhos diretos da raiz</li> <li><code>self.fail[state] = 0</code> - Todos apontam para a raiz</li> <li> <p><code>queue.append(state)</code> - Adiciona \u00e0 fila</p> </li> <li> <p>Processamento BFS (linhas 13-15):</p> </li> <li><code>while queue:</code> - Enquanto h\u00e1 estados para processar</li> <li><code>current_state = queue.popleft()</code> - Remove pr\u00f3ximo estado</li> <li> <p><code>for char, next_state in self.goto[current_state].items():</code> - Para cada transi\u00e7\u00e3o</p> </li> <li> <p>Encontra estado de falha (linhas 19-21):</p> </li> <li><code>failure_state = self.fail[current_state]</code> - Inicia no failure do pai</li> <li><code>while failure_state != 0 and char not in self.goto[failure_state]:</code> - Busca onde o caractere existe</li> <li> <p><code>failure_state = self.fail[failure_state]</code> - Segue cadeia de failures</p> </li> <li> <p>Define failure link (linhas 23-26):</p> </li> <li><code>if char in self.goto[failure_state]:</code> - Se encontrou transi\u00e7\u00e3o v\u00e1lida</li> <li><code>failure_state = self.goto[failure_state][char]</code> - Aponta para o estado correspondente</li> <li> <p><code>self.fail[next_state] = failure_state</code> - Define o failure link</p> </li> <li> <p>Combina sa\u00eddas (linha 29):</p> </li> <li><code>self.output[next_state].update(self.output[failure_state])</code> - Herda padr\u00f5es do failure state</li> </ol>"},{"location":"algoritmos/aho-corasick/#algoritmo-de-busca","title":"Algoritmo de Busca","text":"<pre><code>def search(self, text: str) -&gt; Dict[str, List[Tuple[int, int]]]:\n    \"\"\"\n    Busca todos os padr\u00f5es no texto.\n\n    Returns:\n        Dicion\u00e1rio com padr\u00e3o -&gt; lista de (in\u00edcio, fim) das ocorr\u00eancias\n    \"\"\"\n    if not text:\n        return {}\n\n    # Preprocessa o texto\n    search_text = text if self.case_sensitive else text.lower()\n\n    results = defaultdict(list)\n    current_state = 0\n\n    for i, char in enumerate(search_text):\n        # Encontra o pr\u00f3ximo estado\n        while current_state != 0 and char not in self.goto[current_state]:\n            current_state = self.fail[current_state]\n\n        if char in self.goto[current_state]:\n            current_state = self.goto[current_state][char]\n\n        # Verifica se h\u00e1 padr\u00f5es que terminam neste estado\n        if current_state in self.output:\n            for pattern_idx in self.output[current_state]:\n                pattern = self.patterns[pattern_idx]\n                start_pos = i - len(pattern) + 1\n                end_pos = i + 1\n\n                # Verifica se \u00e9 palavra completa (se necess\u00e1rio)\n                if self.only_whole_words:\n                    if not self._is_whole_word(text, start_pos, end_pos):\n                        continue\n\n                results[pattern].append((start_pos, end_pos))\n\n    return dict(results)\n</code></pre> <p>Explica\u00e7\u00e3o linha por linha:</p> <ol> <li>Valida\u00e7\u00e3o e preprocessamento (linhas 7-13):</li> <li><code>if not text:</code> - Verifica se texto n\u00e3o est\u00e1 vazio</li> <li><code>search_text = text if self.case_sensitive else text.lower()</code> - Normaliza texto</li> <li><code>results = defaultdict(list)</code> - Dicion\u00e1rio para resultados</li> <li> <p><code>current_state = 0</code> - Inicia na raiz do automato</p> </li> <li> <p>Processamento do texto (linha 15):</p> </li> <li> <p><code>for i, char in enumerate(search_text):</code> - Percorre cada caractere com \u00edndice</p> </li> <li> <p>Busca por transi\u00e7\u00e3o v\u00e1lida (linhas 17-18):</p> </li> <li><code>while current_state != 0 and char not in self.goto[current_state]:</code> - Enquanto n\u00e3o encontrar transi\u00e7\u00e3o</li> <li> <p><code>current_state = self.fail[current_state]</code> - Segue failure links</p> </li> <li> <p>Transi\u00e7\u00e3o de estado (linhas 20-21):</p> </li> <li><code>if char in self.goto[current_state]:</code> - Se encontrou transi\u00e7\u00e3o v\u00e1lida</li> <li> <p><code>current_state = self.goto[current_state][char]</code> - Move para pr\u00f3ximo estado</p> </li> <li> <p>Verifica padr\u00f5es encontrados (linhas 23-34):</p> </li> <li><code>if current_state in self.output:</code> - Se h\u00e1 padr\u00f5es terminando aqui</li> <li><code>for pattern_idx in self.output[current_state]:</code> - Para cada padr\u00e3o</li> <li><code>pattern = self.patterns[pattern_idx]</code> - Obt\u00e9m o padr\u00e3o original</li> <li><code>start_pos = i - len(pattern) + 1</code> - Calcula posi\u00e7\u00e3o inicial</li> <li> <p><code>end_pos = i + 1</code> - Posi\u00e7\u00e3o final (exclusiva)</p> </li> <li> <p>Valida\u00e7\u00e3o de palavra completa (linhas 30-33):</p> </li> <li><code>if self.only_whole_words:</code> - Se deve verificar palavras completas</li> <li><code>if not self._is_whole_word(text, start_pos, end_pos):</code> - Verifica boundaries</li> <li> <p><code>continue</code> - Pula se n\u00e3o \u00e9 palavra completa</p> </li> <li> <p>Adiciona resultado (linha 34):</p> </li> <li><code>results[pattern].append((start_pos, end_pos))</code> - Adiciona match encontrado</li> </ol>"},{"location":"algoritmos/aho-corasick/#validacao-de-palavra-completa","title":"Valida\u00e7\u00e3o de Palavra Completa","text":"<pre><code>def _is_whole_word(self, text: str, start: int, end: int) -&gt; bool:\n    \"\"\"Verifica se a ocorr\u00eancia \u00e9 uma palavra completa.\"\"\"\n    # Verifica o caractere anterior\n    if start &gt; 0 and text[start - 1].isalnum():\n        return False\n\n    # Verifica o caractere posterior\n    if end &lt; len(text) and text[end].isalnum():\n        return False\n\n    return True\n</code></pre> <p>Explica\u00e7\u00e3o:</p> <ol> <li>Verifica caractere anterior (linhas 3-4):</li> <li><code>if start &gt; 0 and text[start - 1].isalnum():</code> - Se h\u00e1 caractere anterior alfanum\u00e9rico</li> <li> <p><code>return False</code> - N\u00e3o \u00e9 palavra completa</p> </li> <li> <p>Verifica caractere posterior (linhas 6-7):</p> </li> <li><code>if end &lt; len(text) and text[end].isalnum():</code> - Se h\u00e1 caractere posterior alfanum\u00e9rico</li> <li> <p><code>return False</code> - N\u00e3o \u00e9 palavra completa</p> </li> <li> <p>Confirma palavra completa (linha 9):</p> </li> <li><code>return True</code> - \u00c9 uma palavra completa</li> </ol>"},{"location":"algoritmos/aho-corasick/#busca-com-contexto","title":"Busca com Contexto","text":"<pre><code>def search_with_context(self,\n                      text: str,\n                      context_length: int = 20) -&gt; Dict[str, List[Dict]]:\n    \"\"\"\n    Busca padr\u00f5es retornando contexto adicional.\n\n    Returns:\n        Dicion\u00e1rio com informa\u00e7\u00f5es detalhadas das ocorr\u00eancias\n    \"\"\"\n    results = self.search(text)\n    detailed_results = defaultdict(list)\n\n    for pattern, positions in results.items():\n        for start, end in positions:\n            context_start = max(0, start - context_length)\n            context_end = min(len(text), end + context_length)\n\n            detailed_results[pattern].append({\n                'start': start,\n                'end': end,\n                'match': text[start:end],\n                'context': text[context_start:context_end],\n                'context_start': context_start,\n                'context_end': context_end\n            })\n\n    return dict(detailed_results)\n</code></pre> <p>Explica\u00e7\u00e3o:</p> <ol> <li>Busca b\u00e1sica (linhas 9-10):</li> <li><code>results = self.search(text)</code> - Realiza busca normal</li> <li> <p><code>detailed_results = defaultdict(list)</code> - Dicion\u00e1rio para resultados detalhados</p> </li> <li> <p>Processamento dos resultados (linhas 12-13):</p> </li> <li><code>for pattern, positions in results.items():</code> - Para cada padr\u00e3o encontrado</li> <li> <p><code>for start, end in positions:</code> - Para cada ocorr\u00eancia</p> </li> <li> <p>C\u00e1lculo do contexto (linhas 14-15):</p> </li> <li><code>context_start = max(0, start - context_length)</code> - In\u00edcio do contexto (n\u00e3o negativo)</li> <li> <p><code>context_end = min(len(text), end + context_length)</code> - Fim do contexto (n\u00e3o excede texto)</p> </li> <li> <p>Cria\u00e7\u00e3o do resultado detalhado (linhas 17-24):</p> </li> <li>Dicion\u00e1rio com informa\u00e7\u00f5es completas sobre cada match</li> <li>Inclui posi\u00e7\u00e3o, texto matched, contexto e limites</li> </ol>"},{"location":"algoritmos/aho-corasick/#exemplo-pratico-demonstracao-completa","title":"Exemplo Pr\u00e1tico: Demonstra\u00e7\u00e3o Completa","text":"<pre><code># Exemplo de uso do c\u00f3digo\nif __name__ == \"__main__\":\n    # Exemplo 1: Busca b\u00e1sica\n    patterns = [\"he\", \"she\", \"his\", \"hers\"]\n    text = \"ushers\"\n\n    ac = AhoCorasick(patterns, case_sensitive=False)\n    results = ac.search(text)\n\n    print(\"Exemplo 1 - Busca b\u00e1sica:\")\n    print(f\"Texto: '{text}'\")\n    print(f\"Padr\u00f5es: {patterns}\")\n    print(\"Resultados:\")\n    for pattern, positions in results.items():\n        for start, end in positions:\n            print(f\"  '{pattern}' encontrado em posi\u00e7\u00e3o {start}-{end}\")\n\n    # Sa\u00edda esperada:\n    # 'he' encontrado em posi\u00e7\u00e3o 2-4\n    # 'she' encontrado em posi\u00e7\u00e3o 1-4\n    # 'hers' encontrado em posi\u00e7\u00e3o 2-6\n</code></pre>"},{"location":"algoritmos/aho-corasick/#visualizacao-da-execucao","title":"Visualiza\u00e7\u00e3o da Execu\u00e7\u00e3o","text":"<p>Para o exemplo <code>patterns = [\"he\", \"she\", \"his\", \"hers\"]</code> e <code>text = \"ushers\"</code>:</p> <pre><code>Texto: u s h e r s\nPos:   0 1 2 3 4 5\n\nEstado por posi\u00e7\u00e3o:\n0: u \u2192 estado 0\n1: s \u2192 estado 0\n2: h \u2192 estado 1\n3: e \u2192 estado 2 (encontrou \"he\")\n4: r \u2192 estado 3\n5: s \u2192 estado 4 (encontrou \"hers\")\n\nMatches encontrados:\n- \"he\" nas posi\u00e7\u00f5es 2-4\n- \"she\" nas posi\u00e7\u00f5es 1-4 (via failure link)\n- \"hers\" nas posi\u00e7\u00f5es 2-6\n</code></pre>"},{"location":"algoritmos/aho-corasick/#analise-de-complexidade","title":"An\u00e1lise de Complexidade","text":""},{"location":"algoritmos/aho-corasick/#complexidade-temporal","title":"Complexidade Temporal","text":"<ul> <li>Constru\u00e7\u00e3o da trie: O(\u03a3m) onde \u03a3 \u00e9 a soma dos comprimentos dos padr\u00f5es</li> <li>Constru\u00e7\u00e3o dos failure links: O(\u03a3m)</li> <li>Busca: O(n + z) onde n \u00e9 o tamanho do texto e z \u00e9 o n\u00famero de matches</li> <li>Total: O(n + m + z)</li> </ul>"},{"location":"algoritmos/aho-corasick/#complexidade-espacial","title":"Complexidade Espacial","text":"<ul> <li>Trie: O(\u03a3m) para armazenar todos os estados</li> <li>Failure links: O(n\u00famero de estados)</li> <li>Total: O(\u03a3m)</li> </ul>"},{"location":"algoritmos/aho-corasick/#pros-e-contras","title":"Pr\u00f3s e Contras","text":""},{"location":"algoritmos/aho-corasick/#vantagens","title":"\u2705 Vantagens","text":"<ul> <li>Busca m\u00faltiplos padr\u00f5es simultaneamente</li> <li>Complexidade temporal linear mesmo para muitos padr\u00f5es</li> <li>Flexibilidade de configura\u00e7\u00e3o (case-sensitive, whole words)</li> <li>Informa\u00e7\u00f5es detalhadas sobre as ocorr\u00eancias</li> <li>Robusto para grandes conjuntos de padr\u00f5es</li> </ul>"},{"location":"algoritmos/aho-corasick/#desvantagens","title":"\u274c Desvantagens","text":"<ul> <li>Maior consumo de mem\u00f3ria devido \u00e0 trie</li> <li>Implementa\u00e7\u00e3o mais complexa que algoritmos simples</li> <li>Tempo de constru\u00e7\u00e3o inicial pode ser significativo</li> <li>Overhead para poucos padr\u00f5es</li> </ul>"},{"location":"algoritmos/aho-corasick/#quando-usar","title":"Quando Usar","text":""},{"location":"algoritmos/aho-corasick/#cenarios-ideais","title":"\ud83c\udfaf Cen\u00e1rios Ideais","text":"<ul> <li>Filtros de conte\u00fado com m\u00faltiplas palavras-chave</li> <li>An\u00e1lise de logs com v\u00e1rios padr\u00f5es de erro</li> <li>Detec\u00e7\u00e3o de spam com lista de termos proibidos</li> <li>Bioinform\u00e1tica para busca de sequ\u00eancias</li> <li>Sistemas de monitoramento em tempo real</li> </ul>"},{"location":"algoritmos/aho-corasick/#nao-recomendado","title":"\ud83d\udeab N\u00e3o Recomendado","text":"<ul> <li>Busca de padr\u00e3o \u00fanico (use KMP)</li> <li>Poucos padr\u00f5es muito curtos (overhead desnecess\u00e1rio)</li> <li>Mem\u00f3ria muito limitada (usa mais espa\u00e7o)</li> <li>Padr\u00f5es que mudam frequentemente</li> </ul>"},{"location":"algoritmos/aho-corasick/#exemplo-avancado-sistema-de-moderacao","title":"Exemplo Avan\u00e7ado: Sistema de Modera\u00e7\u00e3o","text":"<pre><code># Sistema de modera\u00e7\u00e3o de coment\u00e1rios\nclass CommentModerator:\n    def __init__(self):\n        # Palavras proibidas\n        forbidden_words = [\n            \"spam\", \"scam\", \"phishing\", \"malware\",\n            \"virus\", \"hack\", \"exploit\", \"bot\"\n        ]\n\n        # Criar moderador com busca por palavras completas\n        self.moderator = AhoCorasick(\n            forbidden_words,\n            case_sensitive=False,\n            only_whole_words=True\n        )\n\n    def moderate_comment(self, comment: str) -&gt; Dict:\n        \"\"\"Modera um coment\u00e1rio e retorna resultado detalhado.\"\"\"\n        # Busca com contexto\n        results = self.moderator.search_with_context(comment, context_length=15)\n\n        # Analisa resultado\n        is_approved = len(results) == 0\n        violations = []\n\n        for pattern, matches in results.items():\n            for match in matches:\n                violations.append({\n                    'word': pattern,\n                    'position': f\"{match['start']}-{match['end']}\",\n                    'context': match['context']\n                })\n\n        return {\n            'approved': is_approved,\n            'violations': violations,\n            'comment': comment,\n            'statistics': self.moderator.get_statistics()\n        }\n\n# Uso do sistema\nmoderator = CommentModerator()\nresult = moderator.moderate_comment(\"This is spam and malware!\")\n\nprint(f\"Aprovado: {result['approved']}\")\nfor violation in result['violations']:\n    print(f\"Viola\u00e7\u00e3o: '{violation['word']}' em {violation['position']}\")\n    print(f\"Contexto: '{violation['context']}'\")\n</code></pre>"},{"location":"algoritmos/aho-corasick/#exercicios-praticos","title":"Exerc\u00edcios Pr\u00e1ticos","text":""},{"location":"algoritmos/aho-corasick/#1-implementacao-de-filtro-de-e-mail","title":"1. Implementa\u00e7\u00e3o de Filtro de E-mail","text":"<p>Crie um filtro que detecte spam usando os padr\u00f5es: <code>[\"free\", \"offer\", \"click\", \"now\", \"urgent\", \"limited\"]</code></p>"},{"location":"algoritmos/aho-corasick/#2-analise-de-logs","title":"2. An\u00e1lise de Logs","text":"<p>Desenvolva um sistema para monitorar logs procurando por: <code>[\"error\", \"exception\", \"failed\", \"timeout\", \"crash\"]</code></p>"},{"location":"algoritmos/aho-corasick/#3-busca-sensivel-ao-contexto","title":"3. Busca Sens\u00edvel ao Contexto","text":"<p>Implemente uma busca que diferencia \"java\" (linguagem) de \"Java\" (ilha).</p>"},{"location":"algoritmos/aho-corasick/#4-visualizacao-de-resultados","title":"4. Visualiza\u00e7\u00e3o de Resultados","text":"<p>Crie uma fun\u00e7\u00e3o que destaque as ocorr\u00eancias encontradas no texto original.</p>"},{"location":"algoritmos/aho-corasick/#referencias","title":"Refer\u00eancias","text":"<ol> <li>Aho, A. V., &amp; Corasick, M. J. (1975). Efficient string matching: an aid to bibliographic search.</li> <li>Cormen, T. H., et al. (2009). Introduction to Algorithms, 3<sup>rd</sup> Edition.</li> <li>Gusfield, D. (1997). Algorithms on Strings, Trees and Sequences.</li> <li>Documenta\u00e7\u00e3o oficial Python: <code>collections.defaultdict</code> e <code>collections.deque</code></li> </ol> <p>Conclus\u00e3o</p> <p>O algoritmo Aho-Corasick \u00e9 uma ferramenta poderosa para busca eficiente de m\u00faltiplos padr\u00f5es. Sua implementa\u00e7\u00e3o em Python oferece flexibilidade e performance, sendo ideal para aplica\u00e7\u00f5es que precisam processar grandes volumes de texto com m\u00faltiplos crit\u00e9rios de busca.</p>"},{"location":"algoritmos/kmp/","title":"Algoritmo KMP (Knuth-Morris-Pratt)","text":"<p>Defini\u00e7\u00e3o</p> <p>O algoritmo KMP \u00e9 um algoritmo eficiente de busca em strings que evita retrocessos desnecess\u00e1rios no texto. Ele pr\u00e9-processa o padr\u00e3o para construir uma tabela de \"failure function\" (fun\u00e7\u00e3o de falha) que permite saltos inteligentes quando ocorre uma falha na compara\u00e7\u00e3o.</p>"},{"location":"algoritmos/kmp/#conceito-e-motivacao","title":"Conceito e Motiva\u00e7\u00e3o","text":""},{"location":"algoritmos/kmp/#o-problema-do-algoritmo-naive","title":"O Problema do Algoritmo Naive","text":"<p>No algoritmo naive, quando encontramos uma falha, voltamos uma posi\u00e7\u00e3o e recome\u00e7amos a compara\u00e7\u00e3o do zero:</p> <pre><code>Texto:    \"ABABCABABA\"\nPadr\u00e3o:   \"ABABA\"\n\nPosi\u00e7\u00e3o 0: ABABA vs ABABA \u274c (falha no 5\u00ba caractere)\n           ^^^^?\nPosi\u00e7\u00e3o 1:  BABA vs ABABA \u274c (volta ao in\u00edcio do padr\u00e3o)\n            ^\n</code></pre>"},{"location":"algoritmos/kmp/#a-solucao-kmp","title":"A Solu\u00e7\u00e3o KMP","text":"<p>O KMP reconhece que quando h\u00e1 uma falha, j\u00e1 sabemos parte da informa\u00e7\u00e3o. N\u00e3o precisamos voltar ao in\u00edcio do padr\u00e3o!</p> <pre><code>Texto:    \"ABABCABABA\"\nPadr\u00e3o:   \"ABABA\"\n\nPosi\u00e7\u00e3o 0: ABAB? vs ABABA \u274c (falha no 5\u00ba caractere)\n           ^^^^\n           Mas \"AB\" no in\u00edcio do padr\u00e3o = \"AB\" que j\u00e1 vimos!\n           Podemos pular direto para comparar a partir do 3\u00ba caractere\n</code></pre>"},{"location":"algoritmos/kmp/#conceitos-fundamentais","title":"Conceitos Fundamentais","text":""},{"location":"algoritmos/kmp/#tabela-lps-longest-proper-prefix-which-is-also-suffix","title":"Tabela LPS (Longest Proper Prefix which is also Suffix)","text":"<p>A tabela LPS armazena, para cada posi\u00e7\u00e3o do padr\u00e3o, o tamanho do maior prefixo pr\u00f3prio que tamb\u00e9m \u00e9 sufixo.</p> <p>Exemplo: Padr\u00e3o \"ABABA\"</p> <pre><code>Posi\u00e7\u00e3o:  0  1  2  3  4\nPadr\u00e3o:   A  B  A  B  A\nLPS:      0  0  1  2  3\n</code></pre> <p>Por qu\u00ea? - Posi\u00e7\u00e3o 0: \"A\" \u2192 n\u00e3o h\u00e1 prefixo pr\u00f3prio \u2192 LPS[0] = 0 - Posi\u00e7\u00e3o 1: \"AB\" \u2192 n\u00e3o h\u00e1 prefixo que seja sufixo \u2192 LPS[1] = 0 - Posi\u00e7\u00e3o 2: \"ABA\" \u2192 \"A\" \u00e9 prefixo e sufixo \u2192 LPS[2] = 1 - Posi\u00e7\u00e3o 3: \"ABAB\" \u2192 \"AB\" \u00e9 prefixo e sufixo \u2192 LPS[3] = 2 - Posi\u00e7\u00e3o 4: \"ABABA\" \u2192 \"ABA\" \u00e9 prefixo e sufixo \u2192 LPS[4] = 3</p>"},{"location":"algoritmos/kmp/#implementacao-em-python","title":"Implementa\u00e7\u00e3o em Python","text":""},{"location":"algoritmos/kmp/#construcao-da-tabela-lps","title":"Constru\u00e7\u00e3o da Tabela LPS","text":"<pre><code>def build_lps_table(pattern):\n    \"\"\"\n    Constr\u00f3i a tabela LPS (Longest Proper Prefix which is also Suffix)\n\n    Args:\n        pattern (str): Padr\u00e3o para o qual construir a tabela\n\n    Returns:\n        list: Tabela LPS\n    \"\"\"\n    m = len(pattern)              # (1) Comprimento do padr\u00e3o\n    lps = [0] * m                 # (2) Inicializa tabela com zeros\n    length = 0                    # (3) Comprimento do prefixo-sufixo atual\n    i = 1                         # (4) Constr\u00f3i a tabela LPS\n    lps = build_lps_table(pattern)\n\n    positions = []                # (5) Lista para armazenar resultados\n    i = 0                        # (6) \u00cdndice para o texto\n    j = 0                        # (7) \u00cdndice para o padr\u00e3o\n\n    # (8) Loop principal de busca\n    while i &lt; n:\n        # (9) Se caracteres coincidem\n        if pattern[j] == text[i]:\n            i += 1               # (10) Avan\u00e7a no texto\n            j += 1               # (11) Avan\u00e7a no padr\u00e3o\n\n        # (12) Se encontrou o padr\u00e3o completo\n        if j == m:\n            positions.append(i - j)  # (13) Adiciona posi\u00e7\u00e3o (in\u00edcio do match)\n            j = lps[j - 1]           # (14) Usa LPS para pr\u00f3xima busca\n\n        # (15) Se h\u00e1 mismatch ap\u00f3s pelo menos um match\n        elif i &lt; n and pattern[j] != text[i]:\n            if j != 0:\n                j = lps[j - 1]   # (16) Usa LPS para evitar retrocesso\n            else:\n                i += 1           # (17) Se j=0, apenas avan\u00e7a no texto\n\n    return positions\n</code></pre>"},{"location":"algoritmos/kmp/#analise-de-complexidade","title":"An\u00e1lise de Complexidade","text":""},{"location":"algoritmos/kmp/#complexidade-temporal","title":"Complexidade Temporal","text":"<ul> <li>Constru\u00e7\u00e3o da tabela LPS: O(m)</li> <li>Busca principal: O(n)</li> <li>Total: O(n + m)</li> </ul> <p>Por que O(n + m)?</p> <ol> <li>Cada caractere do texto \u00e9 examinado no m\u00e1ximo uma vez</li> <li>Backtracking no padr\u00e3o n\u00e3o aumenta a complexidade (devido \u00e0 tabela LPS)</li> <li>Constru\u00e7\u00e3o da LPS \u00e9 linear no tamanho do padr\u00e3o</li> </ol>"},{"location":"algoritmos/kmp/#complexidade-espacial","title":"Complexidade Espacial","text":"<ul> <li>O(m) para a tabela LPS</li> <li>O(k) para armazenar resultados (k = n\u00famero de ocorr\u00eancias)</li> </ul>"},{"location":"algoritmos/kmp/#comparacao-com-algoritmo-naive","title":"Compara\u00e7\u00e3o com Algoritmo Naive","text":"<pre><code>graph TD\n    A[Compara\u00e7\u00e3o de Complexidade] --&gt; B[Algoritmo Naive]\n    A --&gt; C[Algoritmo KMP]\n\n    B --&gt; D[Tempo: O#40;n*m#41;]\n    B --&gt; E[Espa\u00e7o: O#40;1#41;]\n    B --&gt; F[Pior caso: muito lento]\n\n    C --&gt; G[Tempo: O#40;n+m#41;]\n    C --&gt; H[Espa\u00e7o: O#40;m#41;]\n    C --&gt; I[Sempre linear!]</code></pre>"},{"location":"algoritmos/kmp/#exemplo-passo-a-passo","title":"Exemplo Passo a Passo","text":"<p>Vamos buscar o padr\u00e3o \"ABABA\" no texto \"ABABCABABA\":</p>"},{"location":"algoritmos/kmp/#1-construcao-da-tabela-lps","title":"1. Constru\u00e7\u00e3o da Tabela LPS","text":"<pre><code>Padr\u00e3o: A B A B A\n\u00cdndice: 0 1 2 3 4\nLPS:    0 0 1 2 3\n</code></pre>"},{"location":"algoritmos/kmp/#2-busca-kmp","title":"2. Busca KMP","text":"<pre><code>Texto:    A B A B C A B A B A\n\u00cdndice:   0 1 2 3 4 5 6 7 8 9\nPadr\u00e3o:   A B A B A\n          0 1 2 3 4\n\nPasso 1-4: Match A B A B\nPasso 5: text[4]='C' \u2260 pattern[4]='A'\n         j=4 \u2260 0, ent\u00e3o j = lps[3] = 2\n         Continua comparando text[4]='C' com pattern[2]='A'\n\nPasso 6: text[4]='C' \u2260 pattern[2]='A'  \n         j=2 \u2260 0, ent\u00e3o j = lps[1] = 0\n         Continua comparando text[4]='C' com pattern[0]='A'\n\nPasso 7: text[4]='C' \u2260 pattern[0]='A'\n         j=0, ent\u00e3o i++\n\nContinue a busca a partir de text[5]...\n</code></pre>"},{"location":"algoritmos/kmp/#pros-e-contras","title":"Pr\u00f3s e Contras","text":""},{"location":"algoritmos/kmp/#vantagens","title":"Vantagens","text":"<ol> <li>Efici\u00eancia: Complexidade O(n+m) sempre</li> <li>Sem retrocesso: Nunca volta no texto</li> <li>Previs\u00edvel: Performance consistente</li> <li>Otimizado: Evita compara\u00e7\u00f5es desnecess\u00e1rias</li> </ol>"},{"location":"algoritmos/kmp/#desvantagens","title":"Desvantagens","text":"<ol> <li>Complexidade de implementa\u00e7\u00e3o: Mais dif\u00edcil que naive</li> <li>Uso de mem\u00f3ria: Precisa da tabela LPS</li> <li>Overhead: Para padr\u00f5es muito pequenos pode ser mais lento</li> <li>Pr\u00e9-processamento: Tempo adicional para construir LPS</li> </ol>"},{"location":"algoritmos/kmp/#casos-de-uso","title":"Casos de Uso","text":""},{"location":"algoritmos/kmp/#quando-usar-kmp","title":"Quando usar KMP?","text":"<ol> <li>Textos grandes: Quando n &gt;&gt; m</li> <li>Buscas repetidas: Mesmo padr\u00e3o, textos diferentes</li> <li>Padr\u00f5es com repeti\u00e7\u00f5es: Onde naive seria muito lento</li> <li>Performance cr\u00edtica: Quando O(n\u00d7m) \u00e9 inaceit\u00e1vel</li> </ol>"},{"location":"algoritmos/kmp/#exemplos-praticos","title":"Exemplos Pr\u00e1ticos","text":""},{"location":"algoritmos/kmp/#1-busca-em-editores-de-texto","title":"1. Busca em Editores de Texto","text":"<pre><code>def search_in_file(filename, pattern):\n    \"\"\"Busca padr\u00e3o em arquivo usando KMP\"\"\"\n    try:\n        with open(filename, 'r', encoding='utf-8') as file:\n            content = file.read()\n            positions, comparisons = kmp_search(content, pattern)\n\n            return {\n                'filename': filename,\n                'pattern': pattern,\n                'occurrences': len(positions),\n                'positions': positions,\n                'comparisons': comparisons,\n                'text_length': len(content)\n            }\n    except FileNotFoundError:\n        return {'error': f'Arquivo {filename} n\u00e3o encontrado'}\n</code></pre>"},{"location":"algoritmos/kmp/#2-analise-de-sequencias-de-dna","title":"2. An\u00e1lise de Sequ\u00eancias de DNA","text":"<pre><code>def find_dna_sequence(dna_string, target_sequence):\n    \"\"\"\n    Busca sequ\u00eancia espec\u00edfica em string de DNA\n    DNA: apenas A, T, G, C\n    \"\"\"\n    # Valida se s\u00e3o sequ\u00eancias de DNA v\u00e1lidas\n    valid_chars = set('ATGC')\n    if not all(c in valid_chars for c in dna_string.upper()):\n        raise ValueError(\"String de DNA inv\u00e1lida\")\n    if not all(c in valid_chars for c in target_sequence.upper()):\n        raise ValueError(\"Sequ\u00eancia alvo inv\u00e1lida\")\n\n    positions, _ = kmp_search(dna_string.upper(), \n                                   target_sequence.upper())\n\n    return {\n        'target': target_sequence,\n        'found': len(positions) &gt; 0,\n        'positions': positions,\n        'count': len(positions)\n    }\n\n# Exemplo de uso\ndna = \"ATGCATGCATGCAAATGCATGC\"\ntarget = \"ATGC\"\nresult = find_dna_sequence(dna, target)\nprint(f\"Sequ\u00eancia {target} encontrada {result['count']} vezes\")\n</code></pre>"},{"location":"algoritmos/kmp/#3-deteccao-de-padroes-em-logs","title":"3. Detec\u00e7\u00e3o de Padr\u00f5es em Logs","text":"<pre><code>from datetime import datetime\n\ndef analyze_log_patterns(log_content, error_patterns):\n    \"\"\"\n    Analisa logs procurando por padr\u00f5es de erro\n    \"\"\"\n    results = {}\n\n    for pattern_name, pattern in error_patterns.items():\n        positions, comparisons = kmp_search_debug(log_content, pattern)\n\n        # Extrai contexto ao redor de cada ocorr\u00eancia\n        contexts = []\n        for pos in positions:\n            start = max(0, pos - 50)\n            end = min(len(log_content), pos + len(pattern) + 50)\n            context = log_content[start:end]\n            contexts.append(context)\n\n        results[pattern_name] = {\n            'pattern': pattern,\n            'count': len(positions),\n            'positions': positions,\n            'contexts': contexts,\n            'comparisons': comparisons\n        }\n\n    return results\n\n# Exemplo de uso\nerror_patterns = {\n    'connection_error': 'Connection refused',\n    'timeout_error': 'Request timeout',\n    'auth_error': 'Authentication failed'\n}\n\n# log_content seria carregado de um arquivo real\nsample_log = \"\"\"\n2025-01-15 10:30:01 INFO: User login successful\n2025-01-15 10:30:15 ERROR: Connection refused to database\n2025-01-15 10:30:30 ERROR: Request timeout after 30s\n2025-01-15 10:30:45 ERROR: Authentication failed for user admin\n\"\"\"\n\nresults = analyze_log_patterns(sample_log, error_patterns)\nfor pattern_name, data in results.items():\n    if data['count'] &gt; 0:\n        print(f\"{pattern_name}: {data['count']} ocorr\u00eancias\")\n</code></pre>"},{"location":"algoritmos/kmp/#comparacao-de-performance","title":"Compara\u00e7\u00e3o de Performance","text":"<pre><code>import time\nimport random\nimport string\n\ndef benchmark_kmp_vs_naive():\n    \"\"\"Compara performance KMP vs Naive\"\"\"\n\n    def generate_worst_case(n, m):\n        \"\"\"Gera caso onde naive \u00e9 muito ruim\"\"\"\n        text = 'a' * (n - 1) + 'b'\n        pattern = 'a' * (m - 1) + 'b'\n        return text, pattern\n\n    def generate_random_case(n, m):\n        \"\"\"Gera caso aleat\u00f3rio\"\"\"\n        text = ''.join(random.choices('abcdefgh', k=n))\n        pattern = ''.join(random.choices('abcdefgh', k=m))\n        return text, pattern\n\n    test_cases = [\n        (\"Pior caso\", generate_worst_case),\n        (\"Caso aleat\u00f3rio\", generate_random_case)\n    ]\n\n    sizes = [(1000, 10), (5000, 20), (10000, 50)]\n\n    print(\"Compara\u00e7\u00e3o KMP vs Naive\")\n    print(\"=\" * 60)\n\n    for case_name, generator in test_cases:\n        print(f\"\\n{case_name}:\")\n        print(\"-\" * 40)\n\n        for n, m in sizes:\n            text, pattern = generator(n, m)\n\n            # Teste Naive\n            start = time.time()\n            naive_positions, naive_comp = naive_search_debug(text, pattern)\n            naive_time = time.time() - start\n\n            # Teste KMP\n            start = time.time()\n            kmp_positions, kmp_comp = kmp_search_debug(text, pattern)\n            kmp_time = time.time() - start\n\n            # Verifica se resultados s\u00e3o iguais\n            assert naive_positions == kmp_positions, \"Resultados diferentes!\"\n\n            speedup = naive_time / kmp_time if kmp_time &gt; 0 else float('inf')\n\n            print(f\"n={n:5d}, m={m:2d} | \"\n                  f\"Naive: {naive_time:.4f}s ({naive_comp:6d} comp) | \"\n                  f\"KMP: {kmp_time:.4f}s ({kmp_comp:6d} comp) | \"\n                  f\"Speedup: {speedup:.1f}x\")\n\n# Executar benchmark\nbenchmark_kmp_vs_naive()\n</code></pre>"},{"location":"algoritmos/kmp/#visualizacao-do-algoritmo","title":"Visualiza\u00e7\u00e3o do Algoritmo","text":""},{"location":"algoritmos/kmp/#estado-da-busca-kmp","title":"Estado da Busca KMP","text":""},{"location":"algoritmos/kmp/#todo-video-demonstrando","title":"TODO: v\u00eddeo demonstrando","text":""},{"location":"algoritmos/kmp/#variacoes-e-otimizacoes","title":"Varia\u00e7\u00f5es e Otimiza\u00e7\u00f5es","text":""},{"location":"algoritmos/kmp/#1-kmp-com-informacoes-adicionais","title":"1. KMP com Informa\u00e7\u00f5es Adicionais","text":"<pre><code>def kmp_search_extended(text, pattern):\n    \"\"\"KMP que retorna informa\u00e7\u00f5es detalhadas\"\"\"\n    n, m = len(text), len(pattern)\n    lps = build_lps_table(pattern)\n\n    positions = []\n    i = j = 0\n    comparisons = 0\n    lps_usage = 0  # Quantas vezes usamos a tabela LPS\n\n    while i &lt; n:\n        comparisons += 1\n\n        if pattern[j] == text[i]:\n            i += 1\n            j += 1\n\n        if j == m:\n            positions.append(i - j)\n            j = lps[j - 1]\n            lps_usage += 1\n        elif i &lt; n and pattern[j] != text[i]:\n            if j != 0:\n                j = lps[j - 1]\n                lps_usage += 1\n            else:\n                i += 1\n\n    return {\n        'positions': positions,\n        'comparisons': comparisons,\n        'lps_table': lps,\n        'lps_usage_count': lps_usage,\n        'efficiency': comparisons / n if n &gt; 0 else 0\n    }\n</code></pre>"},{"location":"algoritmos/kmp/#2-kmp-com-case-insensitive","title":"2. KMP com Case-Insensitive","text":"<pre><code>def kmp_search_case_insensitive(text, pattern):\n    \"\"\"KMP ignorando mai\u00fasculas/min\u00fasculas\"\"\"\n    return kmp_search(text.lower(), pattern.lower())\n</code></pre>"},{"location":"algoritmos/kmp/#exercicios-praticos","title":"Exerc\u00edcios Pr\u00e1ticos","text":"<p>Exerc\u00edcio 1: Implementa\u00e7\u00e3o da Tabela LPS</p> <p>Implemente uma fun\u00e7\u00e3o que, dado um padr\u00e3o, retorne n\u00e3o apenas a tabela LPS, mas tamb\u00e9m uma explica\u00e7\u00e3o de como cada valor foi calculado.</p> <p>Exerc\u00edcio 2: KMP para M\u00faltiplos Padr\u00f5es</p> <p>Modifique o algoritmo KMP para buscar m\u00faltiplos padr\u00f5es de uma s\u00f3 vez (dica: ser\u00e1 uma introdu\u00e7\u00e3o ao Aho-Corasick).</p> <p>Exerc\u00edcio 3: An\u00e1lise de Casos Extremos</p> <p>Encontre exemplos de padr\u00f5es onde o KMP realmente brilha comparado ao naive (ex: padr\u00f5es com muitas repeti\u00e7\u00f5es).</p> <p>Exerc\u00edcio 4: Busca Circular</p> <p>Implemente uma vers\u00e3o do KMP que busque padr\u00f5es em uma string circular (onde o final se conecta ao in\u00edcio).</p> <p>Exerc\u00edcio 5: Visualizador de KMP</p> <p>Crie uma fun\u00e7\u00e3o que gere uma representa\u00e7\u00e3o visual do processo de busca KMP, mostrando como os \u00edndices se movem.</p> <p>Pr\u00f3ximo: Rabin-Karp</p>"},{"location":"algoritmos/naive/","title":"Algoritmo Naive (For\u00e7a Bruta)","text":"<p>Defini\u00e7\u00e3o</p> <p>O algoritmo Naive, tamb\u00e9m conhecido como for\u00e7a bruta, \u00e9 a abordagem mais simples e intuitiva para busca de padr\u00f5es em strings. Ele verifica todas as posi\u00e7\u00f5es poss\u00edveis do texto, comparando caractere por caractere.</p>"},{"location":"algoritmos/naive/#conceito-e-motivacao","title":"\ud83e\udde0 Conceito e Motiva\u00e7\u00e3o","text":"<p>O algoritmo Naive resolve o problema da busca em strings da forma mais direta poss\u00edvel:</p> <ol> <li>Para cada posi\u00e7\u00e3o no texto</li> <li>Compare o padr\u00e3o com a substring naquela posi\u00e7\u00e3o</li> <li>Se todos os caracteres coincidirem, padr\u00e3o encontrado</li> <li>Caso contr\u00e1rio, move para a pr\u00f3xima posi\u00e7\u00e3o</li> </ol>"},{"location":"algoritmos/naive/#exemplo-visual","title":"Exemplo Visual","text":"<pre><code>Texto:    \"ABABCABABA\"\nPadr\u00e3o:   \"ABABA\"\n\nTentativa 1: ABABA vs ABABA \u2713 (Encontrado na posi\u00e7\u00e3o 0)\n             ^^^^^\nTentativa 2:  BABA vs ABABA \u2717\n              ^^^^\nTentativa 3:   ABA vs ABABA \u2717\n               ^^^\n...e assim por diante\n</code></pre>"},{"location":"algoritmos/naive/#implementacao-em-python","title":"\ud83d\udcbb Implementa\u00e7\u00e3o em Python","text":""},{"location":"algoritmos/naive/#versao-basica","title":"Vers\u00e3o B\u00e1sica","text":"<pre><code>def naive_search(text, pattern):\n    \"\"\"\n    Busca naive de padr\u00e3o em texto.\n\n    Args:\n        text (str): Texto onde buscar\n        pattern (str): Padr\u00e3o a ser encontrado\n\n    Returns:\n        list: Lista com todas as posi\u00e7\u00f5es onde o padr\u00e3o foi encontrado\n    \"\"\"\n    n = len(text)        # Comprimento do texto\n    m = len(pattern)     # Comprimento do padr\u00e3o\n    positions = []       # Lista para armazenar posi\u00e7\u00f5es encontradas\n\n    # Percorre todas as posi\u00e7\u00f5es poss\u00edveis no texto\n    for i in range(n - m + 1):\n        # Verifica se o padr\u00e3o coincide na posi\u00e7\u00e3o i\n        match = True\n        for j in range(m):\n            if text[i + j] != pattern[j]:\n                match = False\n                break\n\n        # Se houve match completo, adiciona a posi\u00e7\u00e3o\n        if match:\n            positions.append(i)\n\n    return positions\n</code></pre>"},{"location":"algoritmos/naive/#analise-linha-por-linha","title":"An\u00e1lise Linha por Linha","text":"<pre><code>def naive_search_detalhado(text, pattern):\n    n = len(text)        # (1) Obt\u00e9m o tamanho do texto\n    m = len(pattern)     # (2) Obt\u00e9m o tamanho do padr\u00e3o\n    positions = []       # (3) Inicializa lista de resultados\n\n    # (4) Loop principal: testa cada posi\u00e7\u00e3o poss\u00edvel\n    for i in range(n - m + 1):  # Por que n-m+1? \n        # Se o texto tem 10 chars e padr\u00e3o tem 3,\n        # s\u00f3 precisamos testar posi\u00e7\u00f5es 0 a 7 (10-3+1=8 posi\u00e7\u00f5es)\n\n        match = True         # (5) Assume que h\u00e1 match inicialmente\n\n        # (6) Loop interno: compara cada caractere\n        for j in range(m):\n            # (7) Compara caractere por caractere\n            if text[i + j] != pattern[j]:\n                match = False    # (8) Se diferente, n\u00e3o h\u00e1 match\n                break           # (9) Sai do loop interno (otimiza\u00e7\u00e3o)\n\n        # (10) Se todos os caracteres coincidiram\n        if match:\n            positions.append(i)  # (11) Adiciona posi\u00e7\u00e3o \u00e0 lista\n\n    return positions            # (12) Retorna todas as posi\u00e7\u00f5es\n</code></pre>"},{"location":"algoritmos/naive/#analise-de-complexidade","title":"\ud83d\udcca An\u00e1lise de Complexidade","text":""},{"location":"algoritmos/naive/#complexidade-temporal","title":"Complexidade Temporal","text":"<ul> <li>Melhor caso: O(n) - padr\u00e3o encontrado logo no in\u00edcio</li> <li>Caso m\u00e9dio: O(n\u00d7m) - depende da distribui\u00e7\u00e3o dos caracteres</li> <li>Pior caso: O(n\u00d7m) - padr\u00e3o nunca encontrado ou encontrado no final</li> </ul> <pre><code># Exemplo do pior caso\ntexto = \"AAAAAAAAAAB\"\npadrao = \"AAAAB\"\n# Teremos que comparar quase todos os caracteres em cada posi\u00e7\u00e3o\n</code></pre>"},{"location":"algoritmos/naive/#complexidade-espacial","title":"Complexidade Espacial","text":"<ul> <li>O(1) - usa apenas algumas vari\u00e1veis auxiliares</li> <li>O(k) se contarmos a lista de resultados, onde k = n\u00famero de ocorr\u00eancias</li> </ul>"},{"location":"algoritmos/naive/#pros-e-contras","title":"\u2696\ufe0f Pr\u00f3s e Contras","text":""},{"location":"algoritmos/naive/#vantagens","title":"\u2705 Vantagens","text":"<ol> <li>Simplicidade: F\u00e1cil de entender e implementar</li> <li>Sem pr\u00e9-processamento: N\u00e3o precisa preparar dados</li> <li>Pouco uso de mem\u00f3ria: Complexidade espacial O(1)</li> <li>Funciona sempre: Nunca falha, sempre encontra se existir</li> </ol>"},{"location":"algoritmos/naive/#desvantagens","title":"\u274c Desvantagens","text":"<ol> <li>Ineficiente: O(n\u00d7m) pode ser muito lento</li> <li>Retrocesso desnecess\u00e1rio: N\u00e3o aproveita informa\u00e7\u00f5es j\u00e1 obtidas</li> <li>Ruim para textos grandes: Performance degrada rapidamente</li> <li>Muitas compara\u00e7\u00f5es redundantes: Re-examina caracteres j\u00e1 vistos</li> </ol>"},{"location":"algoritmos/naive/#casos-de-uso","title":"\ud83c\udfaf Casos de Uso","text":""},{"location":"algoritmos/naive/#quando-usar-o-algoritmo-naive","title":"Quando usar o Algoritmo Naive?","text":"<ol> <li>Textos pequenos: Quando n e m s\u00e3o pequenos</li> <li>Implementa\u00e7\u00e3o r\u00e1pida: Para prot\u00f3tipos ou testes</li> <li>Padr\u00f5es muito pequenos: m \u2264 3 caracteres</li> <li>Uma \u00fanica busca: N\u00e3o vale a pena pr\u00e9-processar</li> </ol>"},{"location":"algoritmos/naive/#exemplo-pratico-filtro-simples","title":"Exemplo Pr\u00e1tico: Filtro Simples","text":"<pre><code>def filtro_palavras_proibidas(texto, palavras_proibidas):\n    \"\"\"\n    Exemplo pr\u00e1tico: filtro de palavras proibidas\n    \"\"\"\n    texto_limpo = texto\n\n    for palavra in palavras_proibidas:\n        # Busca naive para cada palavra proibida\n        positions, _ = naive_search(texto_limpo.lower(), \n                                        palavra.lower())\n\n        # Substitui por asteriscos\n        for pos in reversed(positions):  # Reversed para n\u00e3o afetar \u00edndices\n            texto_limpo = (texto_limpo[:pos] + \n                          '*' * len(palavra) + \n                          texto_limpo[pos + len(palavra):])\n\n    return texto_limpo\n\n# Teste\ntexto = \"Este texto cont\u00e9m palavras inadequadas e conte\u00fado impr\u00f3prio\"\nproibidas = [\"inadequadas\", \"impr\u00f3prio\"]\nresultado = filtro_palavras_proibidas(texto, proibidas)\nprint(resultado)\n# Output: \"Este texto cont\u00e9m palavras *********** e conte\u00fado *********\"\n</code></pre>"},{"location":"algoritmos/naive/#experimentos-e-testes","title":"\ud83e\uddea Experimentos e Testes","text":""},{"location":"algoritmos/naive/#teste-de-performance","title":"Teste de Performance","text":"<pre><code>import time\nimport random\nimport string\n\ndef gerar_texto_aleatorio(tamanho):\n    \"\"\"Gera texto aleat\u00f3rio para testes\"\"\"\n    return ''.join(random.choices(string.ascii_lowercase, k=tamanho))\n\ndef benchmark_naive(tamanhos_texto, tamanho_padrao=5):\n    \"\"\"Testa performance do algoritmo naive\"\"\"\n    resultados = []\n\n    for n in tamanhos_texto:\n        texto = gerar_texto_aleatorio(n)\n        padrao = gerar_texto_aleatorio(tamanho_padrao)\n\n        inicio = time.time()\n        positions, comparisons = naive_search_debug(texto, padrao)\n        fim = time.time()\n\n        resultados.append({\n            'tamanho_texto': n,\n            'tempo': fim - inicio,\n            'comparacoes': comparisons,\n            'ocorrencias': len(positions)\n        })\n\n    return resultados\n\n# Executar benchmark\ntamanhos = [100, 500, 1000, 5000, 10000]\nresultados = benchmark_naive(tamanhos)\n\nfor r in resultados:\n    print(f\"Texto: {r['tamanho_texto']:5d} | \"\n          f\"Tempo: {r['tempo']:.4f}s | \"\n          f\"Compara\u00e7\u00f5es: {r['comparacoes']:6d}\")\n</code></pre>"},{"location":"algoritmos/naive/#variacoes-do-algoritmo-naive","title":"Varia\u00e7\u00f5es do Algoritmo Naive","text":""},{"location":"algoritmos/naive/#1-busca-case-insensitive","title":"1. Busca Case-Insensitive","text":"<pre><code>def naive_search_case_insensitive(text, pattern):\n    \"\"\"Busca ignorando mai\u00fasculas/min\u00fasculas\"\"\"\n    return naive_search(text.lower(), pattern.lower())\n</code></pre>"},{"location":"algoritmos/naive/#2-busca-com-wildcards","title":"2. Busca com Wildcards","text":"<pre><code>def naive_search_wildcard(text, pattern, wildcard='?'):\n    \"\"\"\n    Busca com wildcard (? = qualquer caractere)\n    Exemplo: \"a?c\" encontra \"abc\", \"axc\", \"a1c\", etc.\n    \"\"\"\n    n, m = len(text), len(pattern)\n    positions = []\n\n    for i in range(n - m + 1):\n        match = True\n        for j in range(m):\n            if pattern[j] != wildcard and text[i + j] != pattern[j]:\n                match = False\n                break\n\n        if match:\n            positions.append(i)\n\n    return positions\n\n# Teste\ntexto = \"abcdefghijk\"\npadrao = \"c?e\"  # Deve encontrar \"cde\"\nprint(naive_search_wildcard(texto, padrao))  # [2]\n</code></pre>"},{"location":"algoritmos/naive/#3-busca-de-multiplos-padroes","title":"3. Busca de M\u00faltiplos Padr\u00f5es","text":"<pre><code>def naive_search_multiplos(text, patterns):\n    \"\"\"Busca m\u00faltiplos padr\u00f5es usando algoritmo naive\"\"\"\n    resultados = {}\n\n    for pattern in patterns:\n        resultados[pattern] = naive_search(text, pattern)\n\n    return resultados\n\n# Teste\ntexto = \"abcabcabc\"\npadroes = [\"abc\", \"bca\", \"cab\"]\nresultados = naive_search_multiplos(texto, padroes)\nfor padrao, posicoes in resultados.items():\n    print(f\"'{padrao}': {posicoes}\")\n</code></pre>"},{"location":"algoritmos/naive/#exercicios-praticos","title":"Exerc\u00edcios Pr\u00e1ticos","text":"<p>Exerc\u00edcio 1: Implementa\u00e7\u00e3o B\u00e1sica</p> <p>Implemente uma vers\u00e3o do algoritmo naive que retorne apenas a primeira ocorr\u00eancia do padr\u00e3o.</p> <p>Exerc\u00edcio 2: Contador de Ocorr\u00eancias</p> <p>Modifique o algoritmo para contar quantas vezes o padr\u00e3o aparece no texto (sem armazenar posi\u00e7\u00f5es).</p> <p>Exerc\u00edcio 3: Busca Bidirecional</p> <p>Implemente uma vers\u00e3o que busque o padr\u00e3o tanto da esquerda para direita quanto da direita para esquerda.</p> <p>Exerc\u00edcio 4: An\u00e1lise de Complexidade</p> <p>Crie casos de teste que demonstrem o melhor e pior caso do algoritmo.</p> <p>Pr\u00f3ximo: KMP (Knuth-Morris-Pratt) - Vamos ver como evitar os retrocessos desnecess\u00e1rios! \ud83d\ude80</p>"},{"location":"algoritmos/rabin-karp/","title":"Algoritmo de Busca de Rabin-Karp","text":""},{"location":"algoritmos/rabin-karp/#definicao","title":"Defini\u00e7\u00e3o","text":"<p>O Algoritmo de Rabin-Karp \u00e9 uma t\u00e9cnica eficiente para encontrar substrings dentro de uma string. Ele utiliza hashing para comparar rapidamente os hashes das subsequ\u00eancias do texto com o hash do padr\u00e3o, em vez de comparar cada caractere individualmente.</p>"},{"location":"algoritmos/rabin-karp/#contexto-historico","title":"Contexto hist\u00f3rico","text":"<p>O Rabin-Karp foi desenvolvido por Michael O. Rabin e Richard M. Karp em 1987, onde foram uns dos pioneiros a usar a t\u00e9cnica de hashing para buscar padr\u00f5es, o qual permitiu a busca de multiplos padr\u00f5es.</p>"},{"location":"algoritmos/rabin-karp/#base-teorica","title":"Base te\u00f3rica","text":"<p>Primeiro definimos uma fun\u00e7\u00e3o de dispers\u00e3o, algoritmo que transforma os dados de entrada em um \u00edndice. Depois, \u00e9 calculado o valor de hash do padr\u00e3o que desejamos encontrar. Ap\u00f3s determinar o hash que queremos encontrar, iniciamos a busca dentro do texto, dentro de uma substring, um pequeno peda\u00e7o do texto por vez. Se os valores do hash substring correspoderem, uma nova compara\u00e7\u00e3o \u00e9 feita para verificar a correspond\u00eancia, pois substrings diferentes podem gerar o mesmo valor de hash, onde chamamos de colis\u00e3o. Para ganhos utilizamos a t\u00e9cnica de rolling hash para haja um ganho de efici\u00eancia no algoritmo.</p>"},{"location":"algoritmos/rabin-karp/#rolling-hash","title":"Rolling hash","text":"<p>O Rolling hash rata-se de uma t\u00e9cnica que permite calcular o hash de todas as substrings de tamanho fixo de forma eficiente. Inv\u00e9s de calcularmos o valor do hash novamente,o Rolling hash atualiza o valor da hash da substring anterior, subtraindo o valor do primeiro caracter e somando o valor do primeiro caracter, acessando o novo valor de uma nova substring. No contexto Rabin-Karp, significa remover o caracter mais \u00e0 esquerda e adicionar o valor do caracter que entra na nova substring.</p>"},{"location":"algoritmos/rabin-karp/#funcionamento","title":"Funcionamento","text":"<ol> <li>Gera\u00e7\u00e3o de Hash: O algoritmo gera um \"hash\" para o padr\u00e3o e para cada subsequ\u00eancia do texto que tem o mesmo comprimento do padr\u00e3o.</li> <li>Compara\u00e7\u00e3o de Hashes: Os hashes s\u00e3o comparados. Se houver uma correspond\u00eancia, o algoritmo faz uma compara\u00e7\u00e3o detalhada dos caracteres para garantir que houve uma verdadeira correspond\u00eancia.</li> <li>Deslocamento: O hash da subsequ\u00eancia do texto \u00e9 atualizado a cada movimento de janela, de forma a n\u00e3o precisar recalcular o hash para todos os caracteres da nova janela.</li> </ol>"},{"location":"algoritmos/rabin-karp/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<ol> <li>Pr\u00e9-processamento: Calcula o valor do hash do padr\u00e3o e inicializa o valor hash para as substrings do texto</li> <li>Busca: Desliza a janela sobre o texto, atualiza o hash da substring atual e compara com o hash do padr\u00e3o.</li> </ol>"},{"location":"algoritmos/rabin-karp/#vantagens","title":"Vantagens","text":"<ul> <li>Efici\u00eancia: Na m\u00e9dia, o algoritmo tem complexidade O(n + m), onde <code>n</code> \u00e9 o tamanho do texto e <code>m</code> \u00e9 o tamanho do padr\u00e3o.</li> <li>Detec\u00e7\u00e3o r\u00e1pida de poss\u00edveis correspond\u00eancias: Se houver poucas colis\u00f5es de hashes, o algoritmo \u00e9 muito r\u00e1pido.</li> </ul>"},{"location":"algoritmos/rabin-karp/#desvantagens","title":"Desvantagens","text":"<p>Embora ele traga ganhos de efici\u00eancia, ela pode variar dependendo da fun\u00e7\u00e3o hash que ir\u00e1 utilzar, oqual sua complexidade de O(n + m) passa a ser O(n * m) resultando em uma perda de efici\u00eancia e performance.</p>"},{"location":"algoritmos/rabin-karp/#codigo-em-python","title":"C\u00f3digo em Python","text":"<pre><code>def rabin_karp(texto, padrao, base=256, mod=101):\n    n = len(texto)\n    m = len(padrao)\n\n    if m &gt; n: # Verifica se o padr\u00e3o \u00e9 mair que o texto\n        return -1 \n\n    hash_padro = 0  # Hash do padr\u00e3o\n    hash_texto = 0  # Hash da janela atual do texto\n    h = 1  # Valor de \"h\" \u00e9 base^(m-1) % mod\n\n    # Calculando o valor de h (base^(m-1) % mod)\n    for i in range(m - 1):\n        h = (h * base) % mod\n\n    # Calculando o hash do padr\u00e3o e do texto para os primeiros m caracteres\n    for i in range(m):\n        hash_padro = (base * hash_padro + ord(padrao[i])) % mod\n        hash_texto = (base * hash_texto + ord(texto[i])) % mod\n\n    # Comparando os hashes e verificando a correspond\u00eancia\n    for i in range(n - m + 1):\n        if hash_padro == hash_texto:\n            if texto[i:i + m] == padrao:  # Verifica\u00e7\u00e3o final por coincid\u00eancia exata\n                return i\n        if i &lt; n - m:\n            # Atualiza o hash da janela de texto (desloca a janela)\n            hash_texto = (base * (hash_texto - ord(texto[i]) * h) + ord(texto[i + m])) % mod\n            if hash_texto &lt; 0:\n                hash_texto += mod\n\n    return -1  # N\u00e3o encontrou a correspond\u00eancia\n</code></pre>"},{"location":"algoritmos/rabin-karp/#exemplo","title":"Exemplo","text":"<p>Parametros a serem utilizados: - texto = \"abracadabra\" - padr\u00e3o = \"cad\" - base = 256 (padr\u00e3o ASCII) - mod = 101 (n\u00famero primo pequeno para controle de colis\u00e3o)</p> <pre><code>def rabin_karp(texto, padrao, base=256, mod=101):\n    n = len(texto)   # Tamanho do texto = 11\n    m = len(padrao)  # Tamanho do padr\u00e3o = 3\n</code></pre> <p>Verifica\u00e7\u00e3o de tamanho</p> <p>Verifica se o tamanho do padr\u00e3o \u00e9 maior que o texto. Caso seja, ir\u00e1 retornar 1.</p> <pre><code>if m &gt; n:  # Verifica se o padr\u00e3o \u00e9 mair que o texto\n    return -1\n</code></pre> <p>Armazenamento de valores hash</p> <p>Armazena os valores hash do padr\u00e3o e o da substring do texto.</p> <p><pre><code>hash_padro = 0  # Hash do padr\u00e3o\nhash_texto = 0  # Hash da janela atual do texto\nh = 1           # h = base^(m-1) % mod\n</code></pre> C\u00e1lculo</p> <p>Usado depois para remover o caractere mais \u00e0 esquerda da janela no rolling hash.</p> <pre><code>for i in range(m - 1):\n    h = (h * base) % mod\n</code></pre> <p>Inicializa os hashes</p> <p>O ord(char) retorna o c\u00f3digo ASCII de um caractere.</p> <pre><code>for i in range(m):\n    hash_padro = (base * hash_padro + ord(padrao[i])) % mod # Valor do padr\u00e3o\n    hash_texto = (base * hash_texto + ord(texto[i])) % mod  # Primeira janela do texto com o mesmo tamanho do padr\u00e3o\n</code></pre> <p>Percurso das janela</p> <p>Percorre todas as janelas poss\u00edveis do texto de tamanho m.</p> <pre><code>for i in range(n - m + 1):\n</code></pre> <p>Compara\u00e7\u00e3o de hashes</p> <p>Caso haja uma correspond\u00eancia, compara os caracteres diretamente. Caso seja verdadeiro, retorna a sua posi\u00e7\u00e3o.</p> <pre><code>if hash_padro == hash_texto:\n    if texto[i:i + m] == padrao: # Compara\u00e7\u00e3o real letra por letra\n        return i\n</code></pre> <p>Evitar perder performance</p> <p>Evita tentar calcular uma janela al\u00e9m do fim do texto.</p> <pre><code>if i &lt; n - m:\n</code></pre> <p>Atualiza o hash da pr\u00f3xima janela (rolling hash)</p> <p>Remove o caractere da esquerda da janela, multiplica o resultado e adiciona o novo caracter que entrou. Aplica % mod para manter o n\u00famero controlado</p> <pre><code>hash_texto = (base * (hash_texto - ord(texto[i]) * h) + ord(texto[i + m])) % mod\n</code></pre> <p>Corrige os Hashs negativos</p> <p>Esta linha corrige o hash caso ele tenha ficado negativo ap\u00f3s o c\u00e1lculo.</p> <p><pre><code>if hash_texto &lt; 0:\n    hash_texto += mod\n</code></pre> Caso n\u00e3o encontre</p> <p>Caso termine a verifica\u00e7\u00e3o e n\u00e3o encontre o padr\u00e3o, retorna -1, indicando \"N\u00e3o encontrado\"</p> <pre><code> return -1\n</code></pre>"},{"location":"algoritmos/rabin-karp/#saida-esperada-do-exemplo","title":"Sa\u00edda esperada do exemplo","text":"Itera\u00e7\u00e3o Janela Posi\u00e7\u00e3o <code>hash_texto</code> <code>hash_padro</code> Hashs Iguais? Verifica\u00e7\u00e3o direta Resultado 0 <code>\"abr\"</code> 0\u20132 37 63 \u274c \u2014 N\u00e3o encontrado 1 <code>\"bra\"</code> 1\u20133 42 63 \u274c \u2014 N\u00e3o encontrado 2 <code>\"rac\"</code> 2\u20134 96 63 \u274c \u2014 N\u00e3o encontrado 3 <code>\"aca\"</code> 3\u20135 63 63 \u2705 <code>\"aca\" != \"cad\"</code> \u274c Falso positivo 4 <code>\"cad\"</code> 4\u20136 63 63 \u2705 <code>\"cad\" == \"cad\"</code> \u2705 \u2705 Encontrado 5 <code>\"ada\"</code> 5\u20137 87 63 \u274c \u2014 N\u00e3o encontrado 6 <code>\"dab\"</code> 6\u20138 27 63 \u274c \u2014 N\u00e3o encontrado 7 <code>\"abr\"</code> 7\u20139 37 63 \u274c \u2014 N\u00e3o encontrado 8 <code>\"bra\"</code> 8\u201310 42 63 \u274c \u2014 N\u00e3o encontrado"},{"location":"atividades/exercicios/","title":"Rabin-Karp","text":""},{"location":"atividades/implementacoes/","title":"implementa\u00e7\u00e3o Rabin-Karp","text":"<pre><code># Rabin-Karp algorithm in python\n\ndef rabin_karp(texto, padrao, base=256, mod=101):\n    n = len(texto)\n    m = len(padrao)\n\n    if m &gt; n:\n        return -1\n\n    hash_padro = 0  # Hash do padr\u00e3o\n    hash_texto = 0  # Hash da janela atual do texto\n    h = 1  # Valor de \"h\" \u00e9 base^(m-1) % mod\n\n    # Calculando o valor de h (base^(m-1) % mod)\n    for i in range(m - 1):\n        h = (h * base) % mod\n\n    # Calculando o hash do padr\u00e3o e do texto para os primeiros m caracteres\n    for i in range(m):\n        hash_padro = (base * hash_padro + ord(padrao[i])) % mod\n        hash_texto = (base * hash_texto + ord(texto[i])) % mod\n\n    # Comparando os hashes e verificando a correspond\u00eancia\n    for i in range(n - m + 1):\n        if hash_padro == hash_texto:\n            if texto[i:i + m] == padrao:  # Verifica\u00e7\u00e3o final por coincid\u00eancia exata\n                return i\n        if i &lt; n - m:\n            # Atualiza o hash da janela de texto (desloca a janela)\n            hash_texto = (base * (hash_texto - ord(texto[i]) * h) + ord(texto[i + m])) % mod\n            if hash_texto &lt; 0:\n                hash_texto += mod\n\n    return -1  # N\u00e3o encontrou a correspond\u00eancia\n</code></pre> <pre><code>// Rabin-Karp algorithm in Java\n\npublic class RabinKarp {\n  public final static int d = 10;\n\n  static void search(String pattern, String txt, int q) {\n    int m = pattern.length();\n    int n = txt.length();\n    int i, j;\n    int p = 0;\n    int t = 0;\n    int h = 1;\n\n    for (i = 0; i &lt; m - 1; i++)\n      h = (h * d) % q;\n\n    // Calculate hash value for pattern and text\n    for (i = 0; i &lt; m; i++) {\n      p = (d * p + pattern.charAt(i)) % q;\n      t = (d * t + txt.charAt(i)) % q;\n    }\n\n    // Find the match\n    for (i = 0; i &lt;= n - m; i++) {\n      if (p == t) {\n        for (j = 0; j &lt; m; j++) {\n          if (txt.charAt(i + j) != pattern.charAt(j))\n            break;\n        }\n\n        if (j == m)\n          System.out.println(\"Pattern is found at position: \" + (i + 1));\n      }\n\n      if (i &lt; n - m) {\n        t = (d * (t - txt.charAt(i) * h) + txt.charAt(i + m)) % q;\n        if (t &lt; 0)\n          t = (t + q);\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    String txt = \"ABCCDDAEFG\";\n    String pattern = \"CDD\";\n    int q = 13;\n    search(pattern, txt, q);\n  }\n}\n</code></pre>"},{"location":"introducao/objetivos/","title":"Objetivos de Aprendizagem","text":""},{"location":"introducao/objetivos/#objetivos-gerais","title":"Objetivos Gerais","text":"<p>Ao concluir esta WebQuest, voc\u00ea ser\u00e1 capaz de dominar os algoritmos fundamentais de busca em strings, compreendendo suas caracter\u00edsticas, implementa\u00e7\u00f5es e aplica\u00e7\u00f5es pr\u00e1ticas no desenvolvimento de software e an\u00e1lise de dados.</p>"},{"location":"introducao/objetivos/#objetivos-especificos","title":"Objetivos Espec\u00edficos","text":""},{"location":"introducao/objetivos/#conhecimento-conceitual","title":"\ud83c\udfaf Conhecimento Conceitual","text":""},{"location":"introducao/objetivos/#1-compreender-fundamentos-teoricos","title":"1. Compreender Fundamentos Te\u00f3ricos","text":"<ul> <li>Definir o problema de busca em strings e sua import\u00e2ncia</li> <li>Explicar os conceitos de padr\u00e3o, texto e complexidade algor\u00edtmica</li> <li>Identificar cen\u00e1rios onde cada algoritmo \u00e9 mais apropriado</li> <li>Relacionar busca em strings com outras \u00e1reas da computa\u00e7\u00e3o</li> </ul>"},{"location":"introducao/objetivos/#2-dominar-complexidade-algoritmica","title":"2. Dominar Complexidade Algor\u00edtmica","text":"<ul> <li>Analisar complexidade temporal e espacial de cada algoritmo</li> <li>Comparar performance entre diferentes abordagens</li> <li>Calcular complexidade para casos espec\u00edficos</li> <li>Interpretar nota\u00e7\u00e3o Big O, Omega e Theta</li> </ul>"},{"location":"introducao/objetivos/#habilidades-praticas","title":"\ud83d\udcbb Habilidades Pr\u00e1ticas","text":""},{"location":"introducao/objetivos/#3-implementar-algoritmos","title":"3. Implementar Algoritmos","text":"<ul> <li>Codificar o algoritmo Naive de forma eficiente</li> <li>Construir a tabela LPS para o algoritmo KMP</li> <li>Implementar rolling hash no Rabin-Karp</li> <li>Desenvolver aut\u00f4mato finito para Aho-Corasick</li> </ul>"},{"location":"introducao/objetivos/#4-otimizar-e-depurar-codigo","title":"4. Otimizar e Depurar C\u00f3digo","text":"<ul> <li>Identificar gargalos de performance</li> <li>Aplicar t\u00e9cnicas de otimiza\u00e7\u00e3o</li> <li>Usar ferramentas de profiling</li> <li>Corrigir bugs em implementa\u00e7\u00f5es complexas</li> </ul>"},{"location":"introducao/objetivos/#analise-e-avaliacao","title":"\ud83d\udd0d An\u00e1lise e Avalia\u00e7\u00e3o","text":""},{"location":"introducao/objetivos/#5-realizar-analise-comparativa","title":"5. Realizar An\u00e1lise Comparativa","text":"<ul> <li>Medir performance em diferentes cen\u00e1rios</li> <li>Criar benchmarks representativos</li> <li>Documentar resultados de forma clara</li> <li>Justificar escolhas algor\u00edtmicas</li> </ul>"},{"location":"introducao/objetivos/#6-avaliar-aplicabilidade","title":"6. Avaliar Aplicabilidade","text":"<ul> <li>Selecionar algoritmo apropriado para cada problema</li> <li>Considerar trade-offs entre tempo e espa\u00e7o</li> <li>Avaliar escalabilidade das solu\u00e7\u00f5es</li> <li>Propor otimiza\u00e7\u00f5es espec\u00edficas</li> </ul>"},{"location":"introducao/objetivos/#aplicacao-pratica","title":"\ud83d\ude80 Aplica\u00e7\u00e3o Pr\u00e1tica","text":""},{"location":"introducao/objetivos/#7-resolver-problemas-reais","title":"7. Resolver Problemas Reais","text":"<ul> <li>Desenvolver filtro de conte\u00fado usando Aho-Corasick</li> <li>Implementar detector de pl\u00e1gio com Rabin-Karp</li> <li>Criar ferramenta de busca em logs</li> <li>Construir analisador de sequ\u00eancias biol\u00f3gicas</li> </ul>"},{"location":"introducao/objetivos/#8-apresentar-solucoes","title":"8. Apresentar Solu\u00e7\u00f5es","text":"<ul> <li>Documentar implementa\u00e7\u00f5es de forma profissional</li> <li>Criar visualiza\u00e7\u00f5es dos algoritmos</li> <li>Explicar escolhas de design</li> <li>Demonstrar funcionamento atrav\u00e9s de exemplos</li> </ul>"},{"location":"introducao/objetivos/#taxonomia-de-bloom-aplicada","title":"Taxonomia de Bloom Aplicada","text":""},{"location":"introducao/objetivos/#nivel-1-lembrar","title":"N\u00edvel 1: Lembrar \ud83e\udde0","text":"<ul> <li> Listar os quatro algoritmos estudados</li> <li> Definir termos: padr\u00e3o, texto, ocorr\u00eancia</li> <li> Identificar complexidades b\u00e1sicas</li> </ul>"},{"location":"introducao/objetivos/#nivel-2-compreender","title":"N\u00edvel 2: Compreender \ud83d\udca1","text":"<ul> <li> Explicar como funciona cada algoritmo</li> <li> Distinguir entre diferentes abordagens</li> <li> Interpretar diagramas e visualiza\u00e7\u00f5es</li> </ul>"},{"location":"introducao/objetivos/#nivel-3-aplicar","title":"N\u00edvel 3: Aplicar \ud83d\udd27","text":"<ul> <li> Implementar todos os algoritmos em Python</li> <li> Usar algoritmos em problemas espec\u00edficos</li> <li> Aplicar em datasets reais</li> </ul>"},{"location":"introducao/objetivos/#nivel-4-analisar","title":"N\u00edvel 4: Analisar \ud83d\udd0d","text":"<ul> <li> Comparar performance dos algoritmos</li> <li> Examinar casos de melhor/pior performance</li> <li> Decompor problemas complexos</li> </ul>"},{"location":"introducao/objetivos/#nivel-5-avaliar","title":"N\u00edvel 5: Avaliar \ud83d\udcca","text":"<ul> <li> Criticar implementa\u00e7\u00f5es existentes</li> <li> Julgar qual algoritmo usar em cada cen\u00e1rio</li> <li> Validar resultados e medi\u00e7\u00f5es</li> </ul>"},{"location":"introducao/objetivos/#nivel-6-criar","title":"N\u00edvel 6: Criar \ud83c\udfa8","text":"<ul> <li> Desenvolver varia\u00e7\u00f5es dos algoritmos</li> <li> Construir aplica\u00e7\u00f5es completas</li> <li> Sintetizar conhecimentos em projeto final</li> </ul>"},{"location":"introducao/objetivos/#competencias-transversais","title":"Compet\u00eancias Transversais","text":""},{"location":"introducao/objetivos/#pensamento-computacional","title":"\ud83e\uddee Pensamento Computacional","text":"<ul> <li>Decomposi\u00e7\u00e3o: Quebrar problemas complexos em partes menores</li> <li>Reconhecimento de padr\u00f5es: Identificar similaridades entre algoritmos</li> <li>Abstra\u00e7\u00e3o: Focar nos aspectos essenciais</li> <li>Algoritmos: Criar sequ\u00eancias l\u00f3gicas de passos</li> </ul>"},{"location":"introducao/objetivos/#analise-de-dados","title":"\ud83d\udcc8 An\u00e1lise de Dados","text":"<ul> <li>Coleta: Obter m\u00e9tricas de performance</li> <li>Processamento: Limpar e organizar dados</li> <li>Visualiza\u00e7\u00e3o: Criar gr\u00e1ficos informativos</li> <li>Interpreta\u00e7\u00e3o: Extrair insights dos resultados</li> </ul>"},{"location":"introducao/objetivos/#metodo-cientifico","title":"\ud83d\udd2c M\u00e9todo Cient\u00edfico","text":"<ul> <li>Hip\u00f3teses: Formular previs\u00f5es sobre performance</li> <li>Experimenta\u00e7\u00e3o: Testar hip\u00f3teses sistematicamente</li> <li>Observa\u00e7\u00e3o: Coletar dados precisos</li> <li>Conclus\u00e3o: Validar ou refutar hip\u00f3teses</li> </ul>"},{"location":"introducao/objetivos/#indicadores-de-sucesso","title":"Indicadores de Sucesso","text":""},{"location":"introducao/objetivos/#criterios-de-avaliacao","title":"\u2705 Crit\u00e9rios de Avalia\u00e7\u00e3o","text":""},{"location":"introducao/objetivos/#implementacao-40","title":"Implementa\u00e7\u00e3o (40%)","text":"<ul> <li>Corretude: Algoritmos funcionam corretamente</li> <li>Efici\u00eancia: Implementa\u00e7\u00f5es s\u00e3o otimizadas</li> <li>Clareza: C\u00f3digo \u00e9 leg\u00edvel e bem documentado</li> <li>Robustez: Tratamento adequado de casos extremos</li> </ul>"},{"location":"introducao/objetivos/#analise-30","title":"An\u00e1lise (30%)","text":"<ul> <li>Precis\u00e3o: Medi\u00e7\u00f5es s\u00e3o acuradas</li> <li>Profundidade: An\u00e1lise vai al\u00e9m do superficial</li> <li>Compara\u00e7\u00e3o: Avalia\u00e7\u00e3o equilibrada dos algoritmos</li> <li>Visualiza\u00e7\u00e3o: Apresenta\u00e7\u00e3o clara dos resultados</li> </ul>"},{"location":"introducao/objetivos/#aplicacao-20","title":"Aplica\u00e7\u00e3o (20%)","text":"<ul> <li>Relev\u00e2ncia: Problemas escolhidos s\u00e3o significativos</li> <li>Criatividade: Solu\u00e7\u00f5es s\u00e3o inovadoras</li> <li>Completude: Projetos s\u00e3o bem desenvolvidos</li> <li>Funcionalidade: Aplica\u00e7\u00f5es funcionam adequadamente</li> </ul>"},{"location":"introducao/objetivos/#reflexao-10","title":"Reflex\u00e3o (10%)","text":"<ul> <li>Autoavalia\u00e7\u00e3o: Consci\u00eancia do pr\u00f3prio aprendizado</li> <li>Metacogni\u00e7\u00e3o: Reflex\u00e3o sobre processos de pensamento</li> <li>Conex\u00f5es: Liga\u00e7\u00e3o com outros conhecimentos</li> <li>Aplicabilidade: Vis\u00e3o de uso futuro</li> </ul>"},{"location":"introducao/objetivos/#cronograma-sugerido","title":"Cronograma Sugerido","text":"<pre><code>gantt\n    title Cronograma de Aprendizagem\n    dateFormat  YYYY-MM-DD HH:mm\n    axisFormat  %H:%M\n    section Fundamentos\n    Introdu\u00e7\u00e3o           :a1, 2025-07-11 08:20, 2d\n    Problema da Busca    :a2, after a1, 1d\n\n    section Algoritmos\n    Algoritmo Naive      :b1, after a2, 3d\n    KMP                  :b2, after b1, 4d\n    Rabin-Karp          :b3, after b2, 4d\n    Aho-Corasick        :b4, after b3, 5d\n\n    section An\u00e1lise\n    Compara\u00e7\u00e3o          :c1, after b4, 3d\n    Benchmarks          :c2, after c1, 2d\n\n    section Projeto\n    Desenvolvimento     :d1, after c2, 5d\n    Apresenta\u00e7\u00e3o        :d2, after d1, 2d</code></pre>"},{"location":"introducao/objetivos/#recursos-de-autoavaliacao","title":"Recursos de Autoavalia\u00e7\u00e3o","text":""},{"location":"introducao/objetivos/#checklist-de-progresso","title":"\ud83d\udccb Checklist de Progresso","text":""},{"location":"introducao/objetivos/#algoritmo-naive","title":"Algoritmo Naive","text":"<ul> <li> Compreendi o conceito b\u00e1sico</li> <li> Implementei corretamente</li> <li> Analisei a complexidade O(n\u00d7m)</li> <li> Identifiquei limita\u00e7\u00f5es</li> </ul>"},{"location":"introducao/objetivos/#kmp-knuth-morris-pratt","title":"KMP (Knuth-Morris-Pratt)","text":"<ul> <li> Entendi a tabela LPS</li> <li> Implementei build_lps_table()</li> <li> Codifiquei o algoritmo principal</li> <li> Compreendi a complexidade O(n+m)</li> </ul>"},{"location":"introducao/objetivos/#rabin-karp","title":"Rabin-Karp","text":"<ul> <li> Compreendi rolling hash</li> <li> Implementei fun\u00e7\u00e3o hash</li> <li> Tratei colis\u00f5es adequadamente</li> <li> Analisei casos m\u00e9dio e pior</li> </ul>"},{"location":"introducao/objetivos/#aho-corasick","title":"Aho-Corasick","text":"<ul> <li> Entendi a estrutura trie</li> <li> Implementei failure links</li> <li> Codifiquei busca simult\u00e2nea</li> <li> Apliquei em m\u00faltiplos padr\u00f5es</li> </ul>"},{"location":"introducao/objetivos/#metas-de-aprendizagem","title":"\ud83c\udfaf Metas de Aprendizagem","text":"<p>Ao Final desta WebQuest</p> <p>Voc\u00ea ter\u00e1 desenvolvido uma expertise s\u00f3lida em algoritmos de busca em strings, capacitando-o para:</p> <ul> <li>Escolher o algoritmo mais adequado para cada situa\u00e7\u00e3o</li> <li>Implementar solu\u00e7\u00f5es eficientes e robustas</li> <li>Otimizar performance em aplica\u00e7\u00f5es reais</li> <li>Contribuir para projetos que envolvem processamento de texto</li> <li>Prosseguir para t\u00f3picos avan\u00e7ados como processamento de linguagem natural e bioinform\u00e1tica</li> </ul>"},{"location":"introducao/problema/","title":"O Problema da Busca em Strings","text":""},{"location":"introducao/problema/#definicao-do-problema","title":"Defini\u00e7\u00e3o do Problema","text":"<p>A busca em strings (string matching) \u00e9 o problema fundamental de encontrar todas as ocorr\u00eancias de um padr\u00e3o P de comprimento m em um texto T de comprimento n.</p>"},{"location":"introducao/problema/#exemplo-basico","title":"Exemplo B\u00e1sico","text":"<pre><code>Texto:    \"ABABDABACDABABCABCABCABCABC\"\nPadr\u00e3o:   \"ABAB\"\nPosi\u00e7\u00f5es: [0, 15]\n</code></pre>"},{"location":"introducao/problema/#por-que-e-um-problema-importante","title":"Por que \u00e9 um Problema Importante?","text":""},{"location":"introducao/problema/#1-abrangente","title":"1. Abrangente","text":"<p>A busca em strings aparece em praticamente todos os sistemas computacionais:</p> <p>Aplica\u00e7\u00f5es Cotidianas</p> <ul> <li>Editores de texto: Fun\u00e7\u00e3o \"Localizar\" (Ctrl+F)</li> <li>Navegadores web: Busca na p\u00e1gina</li> <li>Bancos de dados: Consultas com LIKE</li> <li>Sistemas operacionais: Comando grep/find</li> </ul>"},{"location":"introducao/problema/#2-desafios-computacionais","title":"2. Desafios Computacionais","text":""},{"location":"introducao/problema/#volume-de-dados","title":"Volume de Dados","text":"<ul> <li>Genoma humano: ~3 bilh\u00f5es de pares de bases</li> <li>Internet: Trilh\u00f5es de p\u00e1ginas web</li> <li>Logs de sistema: Terabytes di\u00e1rios</li> </ul>"},{"location":"introducao/problema/#requisitos-de-performance","title":"Requisitos de Performance","text":"<ul> <li>Tempo real: Buscas devem ser instant\u00e2neas</li> <li>Throughput: Processar milh\u00f5es de consultas/segundo</li> <li>Mem\u00f3ria limitada: Algoritmos devem ser eficientes em espa\u00e7o</li> </ul>"},{"location":"introducao/problema/#3-complexidade-de-algoritmo","title":"3. Complexidade de Algoritmo","text":""},{"location":"introducao/problema/#abordagem-ingenua","title":"Abordagem Ing\u00eanua","text":"<pre><code>def busca_ingenua(texto, padrao):\n    n, m = len(texto), len(padrao)\n    for i in range(n - m + 1):\n        if texto[i:i+m] == padrao:\n            return i\n    return -1\n</code></pre> <p>Complexidade: O(n\u00d7m) - Ineficiente para textos grandes!</p>"},{"location":"introducao/problema/#cenarios-reais-de-aplicacao","title":"Cen\u00e1rios Reais de Aplica\u00e7\u00e3o","text":""},{"location":"introducao/problema/#1-bioinformatica","title":"1. Bioinform\u00e1tica \ud83e\uddec","text":"<pre><code># Busca de sequ\u00eancias de DNA\ndna = \"ATCGATCGATCGATCG...\"\ngene = \"ATCGATCG\"\n# Encontrar todas as ocorr\u00eancias do gene\n</code></pre> <p>Desafios: - Genomas com bilh\u00f5es de nucleot\u00eddeos - Milhares de genes para buscar - Toler\u00e2ncia a muta\u00e7\u00f5es</p>"},{"location":"introducao/problema/#2-seguranca-cibernetica","title":"2. Seguran\u00e7a Cibern\u00e9tica \ud83d\udee1\ufe0f","text":"<pre><code># Detec\u00e7\u00e3o de malware por assinaturas\narquivo_suspeito = \"...\"\nassinaturas_malware = [\"virus_sig1\", \"trojan_sig2\", ...]\n# Buscar m\u00faltiplas assinaturas simultaneamente\n</code></pre> <p>Desafios: - Milhares de assinaturas conhecidas - Arquivos de gigabytes - Processamento em tempo real</p>"},{"location":"introducao/problema/#3-processamento-de-linguagem-natural","title":"3. Processamento de Linguagem Natural \ud83d\udcdd","text":"<pre><code># An\u00e1lise de sentimentos\ntexto = \"Este produto \u00e9 fant\u00e1stico e recomendo!\"\npalavras_positivas = [\"fant\u00e1stico\", \"\u00f3timo\", \"excelente\", ...]\n# Encontrar termos que indicam sentimento\n</code></pre> <p>Desafios: - Dicion\u00e1rios com milhares de termos - Processamento de documentos extensos - An\u00e1lise multil\u00edngue</p>"},{"location":"introducao/problema/#metricas-de-avaliacao","title":"M\u00e9tricas de Avalia\u00e7\u00e3o","text":""},{"location":"introducao/problema/#1-complexidade-temporal","title":"1. Complexidade Temporal","text":"<ul> <li>Pr\u00e9-processamento: Tempo para preparar estruturas auxiliares</li> <li>Busca: Tempo para encontrar ocorr\u00eancias</li> <li>Pior caso vs. Caso m\u00e9dio</li> </ul>"},{"location":"introducao/problema/#2-complexidade-espacial","title":"2. Complexidade Espacial","text":"<ul> <li>Mem\u00f3ria adicional necess\u00e1ria</li> <li>Escalabilidade com tamanho do padr\u00e3o/texto</li> </ul>"},{"location":"introducao/problema/#3-casos-de-uso-especificos","title":"3. Casos de Uso Espec\u00edficos","text":"<ul> <li>Padr\u00e3o \u00fanico vs. m\u00faltiplos padr\u00f5es</li> <li>Texto est\u00e1tico vs. streaming </li> <li>Sensibilidade a mai\u00fasculas/min\u00fasculas</li> </ul>"},{"location":"introducao/problema/#classificacao-dos-algoritmos","title":"Classifica\u00e7\u00e3o dos Algoritmos","text":""},{"location":"introducao/problema/#por-estrategia","title":"Por Estrat\u00e9gia","text":"Estrat\u00e9gia Algoritmos Caracter\u00edstica For\u00e7a Bruta Naive Simples, ineficiente Pr\u00e9-processamento do Padr\u00e3o KMP, Boyer-Moore Evita compara\u00e7\u00f5es desnecess\u00e1rias Hashing Rabin-Karp Compara\u00e7\u00e3o r\u00e1pida via hash Aut\u00f4matos Aho-Corasick M\u00faltiplos padr\u00f5es simultaneamente"},{"location":"introducao/problema/#por-aplicacao","title":"Por Aplica\u00e7\u00e3o","text":"Cen\u00e1rio Algoritmo Recomendado Motivo Padr\u00e3o \u00fanico, texto pequeno Naive Simplicidade Padr\u00e3o \u00fanico, texto grande KMP Efici\u00eancia linear Hashing dispon\u00edvel Rabin-Karp Flexibilidade M\u00faltiplos padr\u00f5es Aho-Corasick Busca simult\u00e2nea"},{"location":"introducao/problema/#questoes-para-reflexao","title":"Quest\u00f5es para Reflex\u00e3o","text":"<p>Pense sobre isso...</p> <ol> <li>Por que o algoritmo naive pode ser problem\u00e1tico para textos grandes?</li> <li>Qual seria o impacto de usar um algoritmo ineficiente no Google?</li> <li>Como a escolha do algoritmo afeta a experi\u00eancia do usu\u00e1rio?</li> <li>Quais s\u00e3o os trade-offs entre simplicidade e efici\u00eancia?</li> </ol>"},{"location":"recursos/referencias/","title":"Refer\u00eancias","text":"<p>usp.br</p> <p>cp-algorithms.com</p> <p>programiz.com</p> <p>geeksforgeeks.org</p>"}]}